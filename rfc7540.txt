





国际互联网工程任务组（IETF）                                   M. Belshe
意见征求：7540                                                     BitGo
类别：Standards Track                                            R. Peon
国际标准连续出版物编号（ISSN）：2070-1721                    Google, Inc
                                                         M. Thomson, Ed.
                                                                 Mozilla
                                                                May 2015


             超文本转移协议第2版 (HTTP/2)

摘要

   本规范描述了超文本转移协议（HTTP）语义的优化表达，称为HTTP第二版
   （HTTP/2）。通过引入头域压缩并且允许同连接上的多并发交换，HTTP/2
   可以更加高效地使用网络资源并且减少延时感。本文还介绍了表现为从服
   务器到客户端的主动推送。

   本规范是HTTP/1.1的消息语法的替代选项，但不会淘汰HTTP/1.1。HTTP的
   现有语义保持不变。

备忘录状态

   这是一份互联网标准路线文档。

   本文档是国际互联网工程任务组（IETF）的产物。它表示IETF社区的一致意
   见。它接受了大众的审核，并且互联网工程指导小组同意它的发行。关于互
   联网标准的更多信息可以在RFC 5741的第二节获取。

   关于本文的当前状态的信息、任何勘误以及如何对此提供反馈可以从http://w
   ww.rfc-editor.org/info/rfc7540获取。













Belshe, et al.               Standards Track                    [Page 1]

RFC 7540                         HTTP/2                         May 2015


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1. Introduction ....................................................4
   2. HTTP/2 Protocol Overview ........................................5
      2.1. Document Organization ......................................6
      2.2. Conventions and Terminology ................................6
   3. Starting HTTP/2 .................................................7
      3.1. HTTP/2 Version Identification ..............................8
      3.2. Starting HTTP/2 for "http" URIs ............................8
           3.2.1. HTTP2-Settings Header Field .........................9
      3.3. Starting HTTP/2 for "https" URIs ..........................10
      3.4. Starting HTTP/2 with Prior Knowledge ......................10
      3.5. HTTP/2 Connection Preface .................................11
   4. HTTP Frames ....................................................12
      4.1. Frame Format ..............................................12
      4.2. Frame Size ................................................13
      4.3. Header Compression and Decompression ......................14
   5. Streams and Multiplexing .......................................15
      5.1. Stream States .............................................16
           5.1.1. Stream Identifiers .................................21
           5.1.2. Stream Concurrency .................................22
      5.2. Flow Control ..............................................22
           5.2.1. Flow-Control Principles ............................23
           5.2.2. Appropriate Use of Flow Control ....................24
      5.3. Stream Priority ...........................................24
           5.3.1. Stream Dependencies ................................25
           5.3.2. Dependency Weighting ...............................26
           5.3.3. Reprioritization ...................................26
           5.3.4. Prioritization State Management ....................27
           5.3.5. Default Priorities .................................28
      5.4. Error Handling ............................................28
           5.4.1. Connection Error Handling ..........................29
           5.4.2. Stream Error Handling ..............................29



Belshe, et al.               Standards Track                    [Page 2]

RFC 7540                         HTTP/2                         May 2015


           5.4.3. Connection Termination .............................30
      5.5. Extending HTTP/2 ..........................................30
   6. Frame Definitions ..............................................31
      6.1. DATA ......................................................31
      6.2. HEADERS ...................................................32
      6.3. PRIORITY ..................................................34
      6.4. RST_STREAM ................................................36
      6.5. SETTINGS ..................................................36
           6.5.1. SETTINGS Format ....................................38
           6.5.2. Defined SETTINGS Parameters ........................38
           6.5.3. Settings Synchronization ...........................39
      6.6. PUSH_PROMISE ..............................................40
      6.7. PING ......................................................42
      6.8. GOAWAY ....................................................43
      6.9. WINDOW_UPDATE .............................................46
           6.9.1. The Flow-Control Window ............................47
           6.9.2. Initial Flow-Control Window Size ...................48
           6.9.3. Reducing the Stream Window Size ....................49
      6.10. CONTINUATION .............................................49
   7. Error Codes ....................................................50
   8. HTTP Message Exchanges .........................................51
      8.1. HTTP Request/Response Exchange ............................52
           8.1.1. Upgrading from HTTP/2 ..............................53
           8.1.2. HTTP Header Fields .................................53
           8.1.3. Examples ...........................................57
           8.1.4. Request Reliability Mechanisms in HTTP/2 ...........60
      8.2. Server Push ...............................................60
           8.2.1. Push Requests ......................................61
           8.2.2. Push Responses .....................................63
      8.3. The CONNECT Method ........................................64
   9. Additional HTTP Requirements/Considerations ....................65
      9.1. Connection Management .....................................65
           9.1.1. Connection Reuse ...................................66
           9.1.2. The 421 (Misdirected Request) Status Code ..........66
      9.2. Use of TLS Features .......................................67
           9.2.1. TLS 1.2 Features ...................................67
           9.2.2. TLS 1.2 Cipher Suites ..............................68
   10. Security Considerations .......................................69
      10.1. Server Authority .........................................69
      10.2. Cross-Protocol Attacks ...................................69
      10.3. Intermediary Encapsulation Attacks .......................70
      10.4. Cacheability of Pushed Responses .........................70
      10.5. Denial-of-Service Considerations .........................70
           10.5.1. Limits on Header Block Size .......................71
           10.5.2. CONNECT Issues ....................................72
      10.6. Use of Compression .......................................72
      10.7. Use of Padding ...........................................73
      10.8. Privacy Considerations ...................................73



Belshe, et al.               Standards Track                    [Page 3]

RFC 7540                         HTTP/2                         May 2015


   11. IANA Considerations ...........................................74
      11.1. Registration of HTTP/2 Identification Strings ............74
      11.2. Frame Type Registry ......................................75
      11.3. Settings Registry ........................................75
      11.4. Error Code Registry ......................................76
      11.5. HTTP2-Settings Header Field Registration .................77
      11.6. PRI Method Registration ..................................78
      11.7. The 421 (Misdirected Request) HTTP Status Code ...........78
      11.8. The h2c Upgrade Token ....................................78
   12. References ....................................................79
      12.1. Normative References .....................................79
      12.2. Informative References ...................................81
   Appendix A. TLS 1.2 Cipher Suite Black List .......................83
   Acknowledgements ..................................................95
   Authors' Addresses ................................................96

1.  介绍

   超文本转移协议（HTTP）是个非常成功的协议。但是，HTTP/1.1使用底层传输的
   方式（RFC 7230 第6节）有某些特性对如今的应用程序性能造成总体的负面效果。

   特别是，HTTP/1.0在一个给定的TCP连接上，一次只能允许一个请求。HTTP/1.1加
   入了请求管线，但是这仅仅部分解决了请求并发的问题，依然遭受着队头阻塞的
   问题。

   还有，HTTP头域经常重复而冗长。导致不必要的网络流量，同时导致初始的TCP
   拥塞窗口很快变满。当多个请求在同一个新TCP连接上发起时，这会导致过多的
   时延（latency）。

   HTTP/2通过定义一个优化的HTTP语义到底层连接的映射关系来解决这些问题。特
   别是，它允许请求和响应消息在同一个连接上交叉并且使用更加高效的HTTP头域
   编码方式。它还允许请求具有优先级，使得更加重要的请求完成得更快，进一步
   提高了性能。









Belshe, et al.               Standards Track                    [Page 4]

RFC 7540                         HTTP/2                         May 2015


   由此产生的协议对忘了更加友好，因为比HTTP/1.x用了更少的TCP连接。这意味
   着更少的流程间竞争和更长的连接生命周期，相应地导致对可用的网络容量的
   更佳的利用率。

   最后，通过使用二进制消息帧化，HTTP/2还能使消息得到更高效的处理。

2.  HTTP/2协议概览

   HTTP/2为HTTP语义提供了一个优化的传输方式。HTTP/2支持HTTP/1.1的所有核心
   特性并且致力于通过一些手段变得更加高效。

   HTTP/2的基础协议单元是帧（4.1小节）。每种帧服务于不同的目的。例如，
   HEADERS和DATA帧构成了HTTP请求和响应的基础（8.1小节）；其他帧类型像是
   SETTINGS、WINDOW_UPDATE和PUSH_PROMISE是用来支持其他HTTP/2特性的。

   请求的多路复用，是通过让每个HTTP请求/响应的交换关联到它自己的流
   （stream）上来实现的（第5节）。流在很大程度上彼此独立，所以一个阻塞或
   延迟的请求或响应不会阻止其他流上的工作流程。

   流量控制和优先级机制保证了我们可以高效地使用多路复用的流。流量控制
   （5.2小节）有助于保证只有接收者能用到的数据才会被传输。优先级（5.3
   小节）确保有限的资源可以被首先导向到最重要的流。

   HTTP/2添加了一个新的交互模式，服务器可以推送响应到客户端（8.2小节）。
   服务器推送允许一个服务器试着向客户端发送它所预测的客户端需要的
   数据，耗费一些网络资源来换取潜在的时延收益。服务器为此合成一个被
   当做PUSH_PROMISE帧发送的请求。服务器接下来可以在一个独立的流上对这个合
   成的请求发送响应。

   因为在一个连接中使用的HTTP头域可能包含大量的冗余数据，所以含有它们的帧
   需要进行压缩（4.3小节）。特别是在一般场景下，允许很多请求压缩到一个包
   （packet）中，这会对请求大小产生其有利影响。






Belshe, et al.               Standards Track                    [Page 5]

RFC 7540                         HTTP/2                         May 2015


2.1.  文档组织

   HTTP/2规范分为以下四个部分：

   o  启用HTTP/2（第3节）讲述了一个HTTP/2连接是如何被初始化的。

   o  帧层（第4节）和流层（第5节）描述了HTTP/2帧的构成和形成多路复用流的方式。 

   o  帧定义（第6节）和错误定义（第7节）包含了HTTP/2所用的帧和错误的类型的细
      节。

   o  HTTP映射（第8节）和附加要求（第9节）描述了HTTP语义是如何用帧和流来表述
      的。

   由于帧层和流层的一些概念是独立于HTTP的，本规范没有定义一个完全通用的帧层。
   这里的帧层和流层都是根据HTTP协议和服务器推送而定制的。

2.2.  约定和术语

   本文中的关键词"MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、
   "SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"和"OPTIONAL"的解释和
   RFC 2119[RFC2119]文档中描述的一样.

   所有数值使用网络字节的格式。除非另有说明，值都是无符号的。数字根据需要
   用十进制或十六进制表示。十六进制数字以"0x"为前缀，以区别于十进制数字。

   以下术语在文中被使用：

   客户端（client）：初始化HTTP/2连接的端点。客户端发送HTTP请求并接收HTTP响应。

   连接（connection）：  两个端点之间的传输层连接。

   连接错误（connection error）：影响整个HTTP/2连接的错误。

   端点（endpoint）：属于连接的客户端或服务器。






Belshe, et al.               Standards Track                    [Page 6]

RFC 7540                         HTTP/2                         May 2015


   帧（frame）：HTTP/2连接中交换的最小单位，由一个头和一个变长的字节序列
   构成，字节序列按帧的类型来组织结构。

   对等点（peer）：一个端点。当讨论一个特定端点时，“对等方”指的其对应的
   远程端点。

   接收端（receiver）：接受帧的端点。

   发送端（sender）：发送帧的端点。

   服务器（server）：接受HTTP连接的端点。服务器接收HTTP请求并且发送HTTP响
   应。

   流（stream）：HTTP连接中的双向的帧流。

   流错误（stream error）：发生在单个HTTP/2流上的错误。

   最后，术语“网关（gateway）”、“中介（intermediary）”、“代理（proxy）”和
   “隧道（tunnel）在[RFC7230]的2.3节中定义。中介在不同时期分别扮演着客户端
   和服务端的角色。.

   术语“载荷体”在[RFC7230]的3.3节中定义。

3.  启用HTTP/2

   HTTP/2连接是运行在TCP连接（TCP）上的一个应用层协议。客户端是TCP连接的发
   起者。

   HTTP/2使用与HTTP/1.1相同的"http"和"https"的URI模式。HTTP/2使用相同的默
   认端口号："http" URI的80和"https" URI的443。因此，为目标资源的URI处理请求
   时，如"http://example.org/foo"或"https://example.com/bar"，就要求先发现
   上游服务器（客户端当前希望与其建立连接的对等点）是否支持HTTP/2。

   决定是否支持HTTP/2的方式和"http"及"https" URI的不一样。对"http" URI的检测
   在3.2小节中描述。对"http" URI的检测在3.3小节中描述。









Belshe, et al.               Standards Track                    [Page 7]

RFC 7540                         HTTP/2                         May 2015


3.1.  HTTP/2版本标识符

   本文档中定义的协议有两种标识符。

   o  字符串"h2"表示HTTP/2使用了安全传输层协议（TLS）[TLS12]。这个标识是
      用在TLS应用层协议协商（application-layer protocol negotiation ALPN）
      扩展（TLS-ALPN）域上，以及任何HTTP/2运行在TLS上的情况。

      "h2"字符串序列化为两个字节的序列：0x68、0x32，加到ALPN协议标识符里
      面。

   o  字符串"h2c"表示HTTP/2运行在明文的TCP上。这个标识符用在HTTP/1.1的
      Upgrade头域，以及任何HTTP/2运行在TCP上的情况。

      "h2c"字符串从ALPN标识符空间中被保留，但是描述了一个不使用TLS的协议。

   协商"h2"或"h2c"指的是文档中描述的传输、安全、成帧和消息语义的使用。

3.2.  为"http" URI启用HTTP/2

   客户端在不事先知道下一跳是否支持HTTP/2的情况下发起一个请求，会使用HTTP
   Upgrade机制（[RFC7230]的6.7小节）。客户端之所以能这样做，是因为通过发起
   一个Upgrade头域为"h2c"的HTTP/1.1的请求。这样的一个HTTP/1.1请求必须
   （MUST）明确包含一个HTTP2-Settings（3.2.1小节）头域。

   例如：

     GET / HTTP/1.1
     Host: server.example.com
     Connection: Upgrade, HTTP2-Settings
     Upgrade: h2c
     HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>

   客户端在发送HTTP/2的帧之前，包含有效载荷的请求必须（MUST）已经发送。这
   意味着一个很大的请求可以阻塞连接，直到它被发送完毕。

   如果一个初始请求伴随着后续的请求而它的并发性很重要，那么可以使用一个
   OPTIONS请求来执行升级到HTTP/2的操作，代价是一次额外的往返。



Belshe, et al.               Standards Track                    [Page 8]

RFC 7540                         HTTP/2                         May 2015


   不支持HTTP/2的服务器可以在响应请求时不设置Upgrade头域：

     HTTP/1.1 200 OK
     Content-Length: 243
     Content-Type: text/html

     ...

   服务器必须（MUST）忽略在Upgrade头域里的"h2"记号。"h2"记号表示HTTP/2使
   用了TLS，这就需要协商，将会在3.3小节中描述。

   支持HTTP/2的服务器返回101（Switching Protocols）响应，表示接受升级。在
   结束101响应的空行的后面，服务器可以开始发送HTTP/2帧。这些帧必须（MUST）
   包含一个针对初始化升级请求的响应。

   例如：

     HTTP/1.1 101 Switching Protocols
     Connection: Upgrade
     Upgrade: h2c

     [ HTTP/2 connection ...

   服务器发送的第一个HTTP/2帧必须是一个包含SETTING帧（6.5小节）的服务器连
   接开端（3.5小节）。客户端一收到101响应，也必须（MUST）发送一个包含SETTING
   帧的连接开端（3.5小节）。

   升级之前发送的HTTP/1.1请求被分配了一个具有默认优先级（5.3.5小节）的流标
   识符1（5.1.1小节）。流1暗示从客户端到服务器（5.1.1小节）是半关闭的
   （half-closed），因为请求作为一个HTTP/1.1请求已经完成了。HTTP/2连接开始
   后，流1被用于响应。

3.2.1.  HTTP2-Settings头域

   一个从HTTP/1.1到HTTP/2升级的请求必须（MUST）明确包含一个"HTTP2-Settings"
   头域。HTTP-Settings头域是一个专门用于连接的头域，他包含管理HTTP/2连接的
   参数，预期服务器接受请求并升级。

     HTTP2-Settings    = token68



Belshe, et al.               Standards Track                    [Page 9]

RFC 7540                         HTTP/2                         May 2015


   如果此头域确实或者个数超过一个，服务器一定不要（MUST NOT）升级连接到
   HTTP/2。服务器也一定不要再发送这个头域。

   HTTP2-Settings头域的内容是SETTINGS帧（6.5小节）的有效载荷，编码为
   base64url字符串（也就是，[RFC4648]的第5节中描述的URL和文件名安全的Base64
   编码，忽略任何末尾填充的'='字符）。Token68的ABNF[RFC5234]产生式在[RFC7235]
   的2.1小节中定义。

   因为升级仅适用于当前连接，所以发送HTTP2-Settings头域的客户端也必须发送
   作为位于Connection头域的连接选项的"HTTP2-Settings"，以阻止他被转发（参
   看[RFC7230]的6.1小节）。

   服务器解码和解释这些值，就像它对其他SETTINGS帧一样。没有必要对这些设置
   （6.5.3小节）进行，因为101响应相当于隐式的确认。在升级请求中提供这些字
   段值，给了客户端一个在从服务器接受任何帧之前提供参数的机会。

3.3.  为"https" URI启用

   客户端发起对"https" URI的请求是，使用带有应用层协议协商（ALPN）扩展的
   TLS[TLS12]。

   TLS上的HTTP/2使用"h2"协议标识符。"h2c"一定不能（MUST NOT）被客户端发送
   或者被服务器选择；"h2c"协议标识符表示一个协议不使用TLS。

   一旦TLS协商完成，客户端和服务器都必须（MUST）发送一个连接开端（3.5小
   节）。

3.4.  预先知道的情况下启用HTTP/2

   客户端通过其他手段能够知道一个特定的服务器支持HTTP/2。例如，[ALT-SVC]
   描述了一种用来告知（是否）支持HTTP/2功能的机制。

   客户端必须（MUST）发送连接开端（3.5小节），然后可以（MAY）马上向这样的
   服务器发送HTTP/2的帧；服务器能够通过到达的连接开端来识别这些连接。这只
   会影响明文TCP上的HTTP/2连接的建立；支持TLS上的HTTP/2的实现必须（MUST）
   使用TLS[TLS-ALPN]里的协议协商。




Belshe, et al.               Standards Track                   [Page 10]

RFC 7540                         HTTP/2                         May 2015



   相似地，服务器必须（MUST）发送一个连接开端（3.5小节）。

   没有额外的信息的话，预先支持HTTP/2并不是表示服务器在后面的连接中仍会
   支持HTTP/2的强信号。比如，服务器配置可能改变，集群中的服务器配置可能
   不同，或者网络条件发生变化。

3.5.  HTTP/2连接开端

   HTTP/2中，任何端点都需要发送一个连接开端作为协议的最终确认，并且
   还要建立HTTP/2连接的初始配置。客户端和服务器各自发送不同的连接开端。

   客户端连接开端以一个24字节的序列开始，十六进制表示为：

     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

   也就是，连接开端以字符串"PRI *HTTP/2.0\r\n\r\nSM\r\n\r\n"）开始。
   此序列后面必须（MUST）紧跟一个SETTINGS帧（Section 6.5），该帧可以
   （MAY）是空的。客户端一收到101（Switching Protocols切换协议）
   响应（表示一次成功的升级），或者在TLS连接的第一批应用程序数据字节时，
   就发送客户端连接开端。如果客户端在事先知道服务器支持HTTP/2协议的情况下
   发起一个HTTP/2连接，那么一旦连接建立，就会发送客户单的连接开端。

      注意：如果选择客户端连接开端，那么很大一部分HTTP/1.1或HTTP/1.0服务
      器和中介不会试着处理后面的帧。注意这并没有解决[TALKING]中提出的问题。

   服务器连接开端包含一个可能为空的SETTINGS帧（6.5小节），该帧必须（MUST）
   服务器在HTTP/2连接中发送的第一帧。

   发送完连接开端后，必须（MUST）确认一下从另一对等点收到的作为连接开端中
   一部分的SETTINGS帧。




Belshe, et al.               Standards Track                   [Page 11]

RFC 7540                         HTTP/2                         May 2015


   为了避免不必要的时延，允许客户端在发送好客户端连接开端后，无须等待接
   收立服务器连接开端，即向服务器发送附加的帧。有个重点要注意下，无论如
   何，服务器连接开端中的SETTINGS帧可能包含了一些对改变我们期望客户端与
   服务器的通信方式来说必要的参数。一接收到SETTINGS帧，客户端应当遵守这
   些参数。一些配置中，服务器可以在客户端发送附加帧之前传输SETTINGS，提供
   一个可以避免该问题的选项。

   客户端和服务器必须（MUST）把不合法的链接开端当做一个PROTOCOL_ERROR类型
   的连接错误（5.4.1小节）。在这种情况下，GOAWAY帧（6.8小节）可以（MAY）
   被忽略，因为一个不合法的开端意味着对等点不在使用HTTP/2。

4.  HTTP帧

   一旦建立HTTP/2连接，端点就可以开始交换帧了。

4.1.  Frame格式

   所有的帧都是以固定的9字节的头开始，后接一个变长的载荷。

    +-----------------------------------------------+
    |                 Length (24)                   |
    +---------------+---------------+---------------+
    |   Type (8)    |   Flags (8)   |
    +-+-------------+---------------+-------------------------------+
    |R|                 Stream Identifier (31)                      |
    +=+=============================================================+
    |                   Frame Payload (0...)                      ...
    +---------------------------------------------------------------+

                          图 1：帧的布局

   帧头里的字段定义如下：
16,384
   Length:  载荷的长度，一个无符号24位整数。大于2^14（16,384）的值必须不
   能（MUST NOT）发送，除非接收方已经为SETTINGS_MAX_FRAME_SIZE设置一个更
   大的值。

      帧头里的9个字节不算在该值内。





Belshe, et al.               Standards Track                   [Page 12]

RFC 7540                         HTTP/2                         May 2015


   Type:  8位表示的帧类型。帧类型决定了帧的格式和语义。协议的实现必须
     （MUST）忽略和抛弃任何未知类型的帧。

   Flags:  一个8位的字段，专门为帧类型保留的布尔标记。

      Flags给确定的帧类型赋予特定的语义。那些没有对特定帧定义语义的flags
      必须（MUST）被忽略，并且在发送时必须（MUST）保持未设置的状态（0x0）。

   R: 一个1位的保留字段。没有定义它的语义，并且这一位在发送时必须（MUST）
      保持未设置的状态（0x0），在接收时必须（MSUT）被忽略。

   Stream Identifier:  无符号31位整型表示的流标识符（参看5.1.1小节）。值
      0x0用来表示帧跟整条连接相关而非一个独立的流。

   帧载荷的结构和类型完全由帧类型来决定。

4.2.  帧大小

   帧载荷的大小的最大值被接收方声明的SETTINGS_MAX_FRAME_SIZE配置限制。这个
   配置可以是2^14（16,384）到2^24-1（16,777,215）之间的任何值，包括2^24-1
   （16,777,215）在内。

   所有的协议实现必须（MUST）能够接收并至少处理长达2^14字节的帧，在加上那9
   字节的帧头（4.1小节）。在描述帧大小时，并不包括帧头的大小。

      注意：某些帧类型，比如PING（6.7小节），额外限制了载荷数据的大小。

   如果帧超过了SETTINGS_MAX_FRAME_SIZE定义的大小，或者太小以至于不能容纳必
   要的帧数据，端点必须（MUST）发送一个FRAME_SIZE_ERROR的错误码。会改变整
   个连接状态的帧大小错误必须（MUST）被当做连接错误（5.4.1小节）；这包含了
   任何带有头阻塞的帧（4.3小节）（也就是HEADERS、PUSH_PROMISE和
   PUSH_PROMISE）、SETTINGS以及任何流标识符为0的帧。





Belshe, et al.               Standards Track                   [Page 13]

RFC 7540                         HTTP/2                         May 2015


   端点不必用掉帧内所有可用的空间。使用比允许的最大大小小的帧可以提升响应
   性。发送大的帧可能导致对发送时间敏感的帧的延迟（如RST_STREAM、
   WINDOW_UPDATE或PRIORITY），如果这些帧被一个大帧的传输阻塞，就会影响性能

4.3.  Header 压缩和解压

   就像在HTTP/1里，HTTP/2的头域是一个可以有一个或多个值的名称。头域在HTTP
   请求和响应消息中被使用，也在服务器推送操作（8.2小节）中被使用。

   头列表包含零个或更多的头域。当在连接中传输时，头列表被序列化到一个用
   HTTP头压缩[COMPRESSION]头块里。然后将这个头块分成一个或多个字节序列，称
   为头块片段，然后放在HEADERS（6.2小节）、PUSH_PROMISE（6.6小节）或
   CONTINUATION（6。10小节）帧的载荷中传输。

   Cookie头域[COOKIE]被HTTP映射（参看8.1.2.5小节）特殊处理。

   接收数据的端点重组头块的方式是：把头块的帧连接起来，然后解压此块以重建头
   列表。

   一个完整的头块包含两者其一：

   o  设置了END_HEADERS标记的单个HEADERS或PUSH_PROMISE帧，或者

   o  消除了END_HEADERS标记的HEADERS或PUSH_PROMISE帧以及一个或多个CONTINUATION
      帧，最后一个CONTINUATION帧设置有END_HEADERS标记。

   头压缩是有状态的。一个压缩上下文和一个解压上下文在整个连接中都被使用。头
   块中的解码错误必须（MUST）当做COMPRESSION_ERROR类型的连接错误来处理
   （5.4.1小节）。

   每个头块都被当作一个离散的单元处理。头块必须（MUST）作为一串连续的帧来传
   输，中间不能有任何其他类型或者其他流的帧。含有HEADERS或CONTINUATION帧的序列
   中最后一个帧设置有END_HEADERS标记。烟油PUSH_PROMISE或CONTINUATION帧的序列
   中最后一个帧也设置有END_HEADERS标记。这就使一个头块能在逻辑上等同于一个单
   独的帧。




Belshe, et al.               Standards Track                   [Page 14]

RFC 7540                         HTTP/2                         May 2015


   头块的片段只能作为HEADERS、PUSH_PROMISE或者CONTINUATION帧的载荷发送，
   因为这些帧所携带的数据可以修改接收方维护的压缩上下文。一个端点接收到
   HEADERS、PUSH_PROMISE或CONTINUATION帧时需要重组头块并且进行解压，即使
   这些帧要被抛弃。接收方如果没有解压头块，就必须（MUST）用一个
   COMPRESSION_ERROR类型的连接错误（5.4.1小节）来结束连接。

5.  流和多路复用

   在一个HTTP/2连接中，一个流（stream）是一个独立的、双向的、客户端
   和服务器之间交换的帧的序列。流有几个重要的特点：

   o  单个HTTP/2连接可以包含多个并发打开的流，任意一端点从多个流中交错地
      发送帧。

   o  流的建立和使用可以是单方面的，并共享于客户端和服务器。

   o  流可以被任意一端点关闭。

   o  一条流上帧发送的顺序是重要的。接收方按接收的顺序处理帧。特别是，
      在语义上，HEADERS和DATA帧的顺序十分重要。

   o  流用整型来标识区别。端点把流标识符赋给流来初始化这个流。
















Belshe, et al.               Standards Track                   [Page 15]

RFC 7540                         HTTP/2                         May 2015


5.1.  流状态

   流的生命周期在图2中展示。

                                +--------+
                        send PP |        | recv PP
                       ,--------|  idle  |--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------| reserved |          | recv H    | reserved |------.
       |      | (local)  |          |           | (remote) |      |
       |      +----------+          v           +----------+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------|  open  |-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +--------+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half   |          |           |   half   |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----------+          |           +----------+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           | send R /       v        send R / |           |
       |           | recv R     +--------+   recv R   |           |
       | send R /  `----------->|        |<-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `----------------------->|        |<----------------------'
                                +--------+

          send:   端点发送该帧
          recv:   端点接收该帧

          H:  HEADERS帧（隐含CONTINUATION帧）
          PP: PUSH_PROMISE帧（隐含CONTINUATION帧）
          ES: END_STREAM标记
          R:  RST_STREAM帧

                          图 2：流状态

   注意该图只显示了流状态转换以及影响这些转换的帧和标记。就此而言，
   CONTINUATION帧不会导致状态转换；他们跟在是HEADERS或PUSH_PROMISE帧后
   面有效组成部分。




Belshe, et al.               Standards Track                   [Page 16]

RFC 7540                         HTTP/2                         May 2015


   为了达到状态转换的目的，END_STREAM标记被当作一个分隔它所在的帧的事件来
   处理；一个设置了END_STREAM标记的HEADERS帧会引发两次状态转换。

   帧在传输过程中，两端的端点对流的状态的主观认知可能不同。端点不会协调创
   建流；流被任意一端点单方面地创建。发送RST_STREAM之后，状态错位的负面结
   果只会限定在发送RST_STREAM以后的"closed"状态，关闭后的一段时间仍可能会
   收到帧。

   流有下面几种状态：

   空闲（idle）：
      所有的流开始的时候都是"idle"状态。

      下面的转换对于此状态来说是合法的。

      *  发送或接收一个HEADERS帧使得流变成"open"状态。流标识符的选择在5.1.1
         小节中描述。同样的HEADERS帧也可以使得流变成"half-closed"状态。

      *  在另一个流上发送一个PUSH_PROMISE帧，会为将来的使用预留一个空闲的流。
         被预留的流的流状态转换到"reserved (local)"。

      *  在另一个流上收到一个PUSH_PROMISE帧，会为将来的使用预留一个空闲的流。
         被预留的流的流状态转换到"reserved (remote)"。

      *  注意PUSH_PROMISE帧不是在空闲流上发送的，但在Promised Stream ID字段
         中关联新预留的流。

      这种状态下，这条流上接收到除了HEADERS或PUSH_PROMISE（原文是PRIORITY）
      的任何帧必须（MUST）被当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）来
      处理。

   预留（本地）（reserved (local)）：
      "reserved (local)"状态的流是一个已经确认发送过PUSH_PROMISE帧的流。
      PUSH_PROMISE帧预留出一个空闲的流，并用一个远程对等点（8.2小节）打开的
      流来关联这个流。







Belshe, et al.               Standards Track                   [Page 17]

RFC 7540                         HTTP/2                         May 2015


      在这种状态下，只可能有下列转换：

      *  端点可以发送一个HEADERS帧。这会导致流在"half-closed (remote)"的
         状态下打开。

      *  任意一端的端点可以发送RST_STREAM帧，使得流变成"closed"状态。这会
         释放流的保留资源。


      这种状态下，端点必须不（MUST NOT）发送除了HEADERS、RST_STREAM或
      PRIORITY以外的其他任何类型的帧。

      这种状态下，可能（MAY）会收到PRIORITY或WINDOW_UPDATE帧。这种状态下，
      在这条流上，收到除了RST_STREAM、PRIORITY或WINDOW_UPDATE以外的其他任
      何类型的帧，必须（MUST）当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）
      来处理。

   预留（远程）（reserved (remote)）：
      "reserved (remote)"状态下的流已经被远程对等点预留。

      在这种状态下，只能有下列的状态转换：

      *  接收到HEADERS帧会导致流转到"half-closed (local)"状态。

      *  任何一端的端点可以发送RST_STREAM帧来使流变成"closed"状态。这会释
         放流的保留资源。

      端点可以（MAY）在这种状态下发送一个PRIORITY帧来重设预留流的优先级。
      这种状态下端点必须不（MUST NOT）发送除了RST_STREAM、WINDOW_UPDATE或
      PRIORITY以外的其他类型的帧。

      这种状态下的流中，接收到除了HEADERSR、RST_STREAM或PRIORITY以外的其他
      任何类型的帧，必须（MUST）当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）
      来处理。

   打开（open）:
      处于"open"状态的流可以被两端的对等点用来发送任何类型的帧。这种状态下，
      作为发送方的对等点需要监测被（接收方）告知的流层的流控限制（5.2小节）。

      从这个状态触发，任意一端的端点可以发送一个设置有END_STREAM标记的帧，
      引发流转换到两种"half-closed"状态中的一种状态。端点发送END_STREAM
      标记会让流状态变成"half-closed (local)"；端点接收到END_STREAM标记会
      让流状态变成"half-closed (remote)"。





Belshe, et al.               Standards Track                   [Page 18]

RFC 7540                         HTTP/2                         May 2015



      任意一端的端点都可以发送RST_STREAM帧，让它从此状态立即转变成"closed"
      状态。

   半关闭（本地）（half-closed (local)）：
      "half-closed (local)"状态下的流不能用作发送WINDOW_UPDATE、PRIORITY
      和RST_STREAM以外的帧。

      当收到包含END_STREAM标记的帧时，或者当任意一端的对等点发送RST_STREAM
      帧时，流就会从这个状态转换到"closed"状态。

      这种状态下，端点可以接收任何类型的帧。为了继续接收流量控制帧，使用
      WINDOW_UPDATE帧来提供流量控制的点数是必要的。在这种状态下，接收方可
      以忽略WINDOW_UPDATE帧，这些帧可能在含有END_STREAM标记的帧发送以后的
      一小段时间内到达。

      这种状态下收到的PRIORITY帧用来在已识别的流的基础上重新设置流的优先级。

   半关闭（远程）（half-closed (remote)）:
      "half-closed (remote)"的流不再被对等点用于发送帧。在这个状态下，端点
      不再需要维护接收方流量控制窗口。

      在这种状态下，如果一个端点收到额外的帧，除了WINDOW_UPDATE、PRIORITY
      或RST_STREAM以外，流必须（MUST）响应一个STREAM_CLOSED类型的流错误
      （5.4.2小节）。

      "half-closed (remote)"流可以被端点用来发送任何类型的帧。在此状态下，
      端点继续监测被告知的流层流量控制限制（5.2小节）。

      通过发送含有END_STREAM标记的帧，或者当两个对等点的任意一方发送
      RST_STREAM时，流会从此状态转移到"closed"状态。







Belshe, et al.               Standards Track                   [Page 19]

RFC 7540                         HTTP/2                         May 2015


   关闭（closed）：
      "closed"状态是终结状态。

      在一个已关闭的留上，端点必须（MUST）不发送除了PRIORITY以外的帧。
      收到RST_STREAM以后，一个端点接收到除了PRIORITY以外的帧，必须（MUST）
      当作STREAM_CLOSED类型的流错误（5.4.2小节）来处理。相似地，一个端
      点接收到设有END_STREAM标记的帧以后，再接收到任何帧，必须（MUST）
      当做STREAM_CLOSED类型的连接错误来处理，除非这个帧是像下面描述的
      那样才会被允许。

      在这种状态下，在一个含有END_STREAM标记的DATA或者HEADERS帧发送以后，
      在一小段时间内，可以接收WINDOW_UPDATE或者RST_STREAM帧。远程对等点
      会发送这些类型的帧，直到接收并处理RST_STREAM或者带有END_STREAM标
      记的帧。端点必须（MUST）忽略在此状态下接收到的WINDOW_UPDATE或者
      RST_STREAM帧，但也可以（MAY）选择把这些正好在发送完END_STREAM以后
      到达的帧当作PROTOCOL_ERROR的连接错误来处理。

      PRIORITY帧可以在已关闭的流上发送，用来设置那些依赖该流的流的优先级。
      端点应该（SHOULD）处理PRIORITY帧，即使它们可能因为流被从依赖树移除
      （5.3.4小节）而被忽略。

      如果是因为发送RST_STREAM帧而到达这个状态，那么接收RST_STREAM的对等
      点也许已经发送——或者在队列中准备发送——的帧已经无法取回。发送
      RST_STREAM帧以后，端点必须（MUST）忽略从已关闭的流上收到的帧。端点
      可以（MAY）选择限制时间段，在这段时间内他会忽略帧，并将这段时间后
      的帧当做错误处理。

      发送完RST_STREAM以后收到的流量控制帧算作连接流量控制窗口。即使这些
      帧可能会被忽略，因为他们在发送者接收到RST_STREAM之前已经被发出去了，
      发送者会在计算流量控制窗口时算上这些帧。

      端点发送了RST_STREAM以后可能会收到PUSH_PROMISE帧。PUSH_PROMISE使得
      流变成"reserved"状态，即使相关的流已经被重置。因此，需要RST_STREAM
      来关闭不想要的允诺（promised）流。





Belshe, et al.               Standards Track                   [Page 20]

RFC 7540                         HTTP/2                         May 2015


   本文档中的其他地方没有给出更加具体的指导，协议实现应该（SHOULD）将状
   态描述中没有明确允许的帧的接收当作一个PROTOCOL_ERROR类型的连接错误。
   注意PRIORITY可以在任何流状态下被发送。未知类型的帧将被忽略。

   HTTP请求/响应交换的状态转移的一个例子可以在8.1小节中找到。服务器推送
   的状态转移的例子可以在8.2.1和8。2。2小节中找到。

5.1.1.  流标识符

   流被一个31位无符号整数标识。客户端生成的流必须（MUST）使用奇数的流标
   识符；哪些服务器生成的流必须（MUST）使用偶数的流标识符。为零（0x0）
   的流标识符用作连接控制消息；为零的流标识符不能用来创建一个新流。

   升级到HTTP/2（参看3.2小节）的HTTP/1.1请求用流标识符为一（0x1）的流来
   响应。升级成功以后，对客户端来说，流0x1为"half-closed (local)"状态。
   因此，升级自HTTP/1.1的流0x1不能用作客户端新流的标识符。

   新建的流的标识符必须在数值上大于所有创建方已经打开或预留的流。这个规
   则适用于用HEADERS帧打开的流和用PUSH_PROMISE帧预留的流。收到意料之外的
   流标识符的端点必须（MUST）响应一个PROTOCOL_ERROR类型的连接错误（5.4.1
   小节）。

   第一次使用一个新的流标识符时，会默认地关闭所有"idle"状态的流，这些流
   在之前被此对等点创建，并且流标识符相对较小。例如，一个客户端在流7上
   发送了HEADERS帧，但从没在流5上发送过帧，然后当开始为流7发送或接收帧的
   时候，流5将转换为"closed"状态。

   流标识符不能被复用。长生命周期的连接可能导致端点耗尽流标识符的可用范
   围。无法创建新流标识符的的客户端可以为新的流创建一个新的连接。无法创
   建新流标识符的服务器可以发送一个GOAWAY帧，这样客户端就会强制为新流打
   开一个新连接。




Belshe, et al.               Standards Track                   [Page 21]

RFC 7540                         HTTP/2                         May 2015


5.1.2.  流并发

   一个对等点可以使用SETTINGS帧中的SETTINGS_MAX_CONCURRENT_STREAMS参数
   （参看6.5.2小节）来限制并发活动流的数目。最大并发流设置是为了每一个
   端点而设并且仅应用于接收配置的端点。那就是说，客户端定义服务器可以初
   始化的并发流的最大个数，而服务器定义客户端可以初始化的并发流的最大数
   目。

   "open"状态下或者是两种"half-closed"状态下的流计入端点可以打开的流的
   最大数目。这三种状态下的流计入SETTINGS_MAX_CONCURRENT_STREAMS配置所
   声明的限制。两种"reserved"状态下的流不计入这种流限制。

   端点必须不（MUST NOT）超出其对等点设置的限制。端点因接收到HEADERS帧
   端而超出并发流限制，必须（MUST）当做PROTOCOL_ERROR或REFUSED_STREAM类
   型的流错误（5.4.2小节）。错误码的选择取决于端点是否愿意启用自动重试
   功能（详情参看8.1.4小节）。

   希望减少SETTINGS_MAX_CONCURRENT_STREAMS值到比当前已打开的流的个数还低
   的端点，既可以关闭超出部分的流，也可以等待流的完成。

5.2.  流量控制

   使用流来实现多路复用，引入了TCP连接的争用，导致流的阻塞。一个流量控制
   的方案去报同一连接上的流不会破坏性地彼此干扰。流量控制既用于单独的流
   也用于整条连接。

   HTTP/2使用WINDOW_UPDATE帧（6.9小节）来提供流量控制。












Belshe, et al.               Standards Track                   [Page 22]

RFC 7540                         HTTP/2                         May 2015


5.2.1.  流量控制原则

   HTTP/2流的流量控制旨在允许不需要协议变动就可以使用多种流控算法。
   HTTP/2的流量控制具有以下特征：

   1.  流量控制针对于某一连接定义。两种类型的流量控制都是在两个单跳的
       端点之间而非整条端到端的路径。

   2.  流量控制基于WINDOW_UPDATE帧。接收者声明它们准备在一个流上或者在整条
       连接中接收多少字节。这是一种基于点数的方案。

   3.  流量控制是有向的，并且完全由接收方控制。接收方可以（MAY）对每一条流
       或者整条连接设置任意的窗口大小。发送方必须（MUST）遵守接收方设定的
       流量控制的限制。客户端、服务器和中介作为接收方时都独立地声明他们的
       流量控制窗口，并且发送数据时遵守它们对等点的流量控制限制。

   4.  流量控制窗口的初始值是65,535个字节，包括新建的流和整个连接。

   5.  帧的类型决定了流量控制是否应用于帧。本文档中规定的帧中，只有DATA帧
       遵从流量控制；其他任何帧类型不会耗费流量控制窗口里的空间。这就保证了
       关键的控制帧不会被流量控制阻塞。

   6.  流量控制不能被禁用。

   7.  HTTP/2只规定了WINDOW_UPDATE帧（6.9小节）的格式和语义。本文档没有规定
       接收者决定何时发送这个帧以及发送的值，也没有规定发送包的方式。协议实
       可以选择任何适合他们需求的算法。

   协议实现也要负责：管理请求和响应如何按照优先级发送，选择规避请求队头阻塞
   的方法，管理新建的流。关于这些问题的算法的选择可以与任何流控算法互动。




Belshe, et al.               Standards Track                   [Page 23]

RFC 7540                         HTTP/2                         May 2015


5.2.2.  正确使用流量控制

   流量控制用来保护在资源约束下运行的端点。比如，一个代理需要在很多连接之中
   分配内存，也可能上传慢而下载快。流量控制解决了接收方无法在处理一条流上的
   数据但是又想处理同一连接上的其他流的问题。

   部署时不想要这个功能的话，可以声明一个最大值（2^31-1）的流控窗口，并且在
   收到数据的时候用发送WINDOW_UPDATE的方式维护这个窗口。相反地，发送方需要
   一直遵循接收方声明的流量窗口。

   部署时有受约束资源（例如，内存）的话，可以利用流量控制来限制一个对等点能
   消耗的内存量。注意，无论如何，如果在不知道带宽延迟积（bandwidth-delay
   product）（参看[RFC7323]）的情况下使用流量控制，这可能导致无法充分利用可
   用的网络资源。

   即使充分了解当前的带宽延迟积，流控实现也是非常困难的。使用流量控制时，接
   收方必须（MUST）及时从TCP接收缓冲区中读取数据。如果做不到这一点，可能导致
   在关键帧，比如WINDOW_UPDATE，在没有被读取且处理时，就出现死锁。

5.3.  流优先级

   通过在打开流的HEADERS帧（6.2小节）中包含优先级信息，客户端可以给新流分配
   优先级。其他任何时候，可以使用PRIORITY帧（6.3小节）来改变流的优先级。

   设置优先级的目的是，让端点能够表达它希望它的对等点在管理并发流时如何分配
   资源。更重要的是，当发送的容量有限是，优先级可以用来选择可以传输帧的流。

   当流依赖于其他流的完成时，也可以设置优先级来排序。每条依赖关系都被赋了一
   个相对权重，对于那些依赖同一流的不同流，在给这些流分配可用资源时，这个数
   字用来判定其相对优先级。





Belshe, et al.               Standards Track                   [Page 24]

RFC 7540                         HTTP/2                         May 2015


   显式地设置流的优先级会计入到优先级处理流程中。这不能保证流相对于其他
   流的处理和传输的优先级。所以表达优先级只是一个建议。

   可以忽略消息中的优先级信息。对于任何显式给出的数值，优先使用默认值
   （5.3.5小节）。

5.3.1.  流依赖

   任何流都可以显式依赖其他流。依赖表示比起从属流，更加优先给被依赖流分配
   资源。

   不依赖其他任何流的流会被赋予一个值为0x0的流依赖。换句话说，不存在的0号
   流成了依赖树的根节点。

   依赖其他流的流是一个从属流。被一条流依赖的流是一个父流。依赖于暂时不在
   树中的流——比如"idle"状态下的流——导致该流被赋予默认优先级（5.3.4小节）。

   当让一条流依赖于另一条流时，这条流作为新依赖关系的父节点加入到树中。同一
   父节点的从属流之间不会排序。举个例子，如果流B和流C都依赖于流A，流D又创建
   一个依赖于A的依赖关系，那么从依赖顺序上来说，A排在B、C和D的后面，B、C和D
   之间可以是任何顺序。

       A                 A
      / \      ==>      /|\
     B   C             B D C

             图 3：默认依赖创建示例

   一个排他的标记使其可以插入一个新的依赖层。排他标记使流独占其父流的依赖关
   系。在前面的示例中，如果流D创建一个排他依赖关系到，那么D变成B和C的父节点。






Belshe, et al.               Standards Track                   [Page 25]

RFC 7540                         HTTP/2                         May 2015


                         A
       A                 |
      / \      ==>       D
     B   C              / \
                       B   C

            图 4：排他依赖创建示例

   依赖树中的一个从属流应该（SHOULD）只能在两种情况下被分配资源，要么
   它所依赖的所有流（父流直到0x0节点的依赖链）都已经关闭，要么都没法对
   他们做进一步处理。

   流不能依赖于它自己。端点必须（MUST）把这种情况当做PROTOCOL_ERROR类
   型的流错误（5.4.2小节）。

5.3.2.  依赖权重

   所有从属流都被分配了一个1到256（包括1和256）的整数权重。

   同一父节点的流应该（SHOULD）按照基于权重的比例来分配资源。那么，如果
   流B依赖于流A且权重是4，流C依赖于流A且权重是12，流A已经没什么可处理的
   了，流B照道理应该收到分配给流C的三分之一的资源。

5.3.3.  优先级重排

   使用PRIORITY帧可以改变流的优先级。设置依赖关系会使流依赖于其父流。

   如果父流的优先次序发生变化，从属流也随之移动。使用排他标记为一个重排
   后的流设置依赖关系，会导致新父流的所有从属节点全部变成依赖于这个重排
   后的流。

   如果流被设置为依赖于自己的从属节点，那么这个从属流会首先移动到这个被
   重排流之前的父节点下。被移动的从属节点保持自己的权重。

   举个例子，假设初始的依赖树是这样的，B和C依赖于A，D和E依赖于C，F依赖于
   D。如果让A依赖于D，那么D取代了A的位置。其他依赖关系都保持不变，除非使
   用排他重排，这时的F会变成依赖于A。



Belshe, et al.               Standards Track                   [Page 26]

RFC 7540                         HTTP/2                         May 2015


       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==>  F   B   C   ==>    F   A       OR      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  (中间步骤)         (非排他)          (排他)

                图 5：依赖重排示例

5.3.4.  优先级排序状态管理

   当流从依赖树上移除时，它的从属节点也会被移动到该被关闭流的父节点上。新
   从属节点的权重会被重新计算，根据它们的之前的权重瓜分那个被关闭流所占的
   比例。

   从依赖树中移除的流导致某些优先级信息的丢失。资源在同一父流下的流中共享，
   这意味着如果这个集合中的某个流被关闭或阻塞，任何空出的容量都会被分配给
   紧邻它的流。总之，如果从属节点从树中移除，那么那些同级流会和下面一层的
   流分享资源。

   举个例子，假设流A和流B共享一个父节点，并且流C和流D都依赖流A。在移除流A
   之前，如果流A和流D都不能工作了，那么流C会接收所有本来分配给流A的资源。
   如果流A已经被移除出树了，那么流A的权重会在流C和流D中分配。如果这时流D
   还是不可用的话，流C分配到的资源比例比之前那个例子少。如果权重都彼此相
   等，流C收到可用资源的三分之一，而不是之前的一半。

   创建依赖的优先级信息在转移的时候，流是可以关闭的。如果依赖中的流没有任
   何相关联的优先级信息，那么从属流被赋予一个默认的优先级（5.3.5小节）。
   这潜在地创建了非最优的优先排序，因为流可能被赋予了一个非预期的优先级。





Belshe, et al.               Standards Track                   [Page 27]

RFC 7540                         HTTP/2                         May 2015


   为了避免这些问题，在流关闭以后的一段时间内，一个端点应该（SHOULD）维
   护流的优先级排序的状态。这个状态维护得越久，流被赋错优先级或者被赋予
   默认优先级的概率就越低。

   相似地，在"idle"状态下的流可能被赋予优先级或者变成其他流的父流。这就
   可以在依赖树中创建一个分组的节点，这就能使优先级表达更加灵活。空闲流
   以默认优先级（5.3.5小节）开始。



   对流优先级信息的保留不会计入SETTINGS_MAX_CONCURRENT_STREAMS的限制中，
   这会对端点造成很大的状态负担。因此，优先级排序状态的数量可以（MAY）限
   制一下。

   为优先排序而维护的附加状态的数量依负载而定；高负载下，优先级状态可以
   被丢弃来限制资源投入。在极端情况下，端点甚至可以放弃活动或保留的流的
   优先级排序状态。如果施行了限制，端点应该（SHOULD）维护和
   SETTINGS_MAX_CONCURRENT_STREAMS所设置的一样多状态。协议实现还应该
   （SHOULD）试着为在优先级树中使用的流保留状态。

   如果端点保留了足够的状态，它收到一个要修改已关闭的流的优先级的PRIORITY
   帧时，应该（SHOULD）修改依赖该流的从属节点。

5.3.5.  默认优先级

   所有流都被初始地赋予了一个非排他的依赖于流0x0的关系。推送流（8.2小节）
   初始依赖于它们的关联流。两种情况下，流都会被赋予值为16的默认优先级。

5.4.  错误处理

   HTTP/2成帧允许两个类别的错误：

   o  造成整个连接无法使用的错误情形是一个连接错误。

   o  一条单独的流中的错误是一个刘错误。

   错误码列表包含在第7节里。




Belshe, et al.               Standards Track                   [Page 28]

RFC 7540                         HTTP/2                         May 2015


5.4.1.  连接错误处理

   连接错误是任何一种阻碍以后帧层处理或者破坏连接状态的错误。

   遇到连接错误的端点应该（SHOULD）首先通过最后一次从对等点接收成功的流
   发送一个GOAWAY帧（6.8小节）。GOAWAY帧包括一个描述连接关闭原因的错误码。
   为出错情形发送GOAWAY帧以后，端点必须（MUST）关闭TCP连接。

   GOAWAY帧可能不会被接收端可靠地接收（[RFC7230]，6.6小节描述了连接马上
   关闭是怎样导致数据流失的）。连接错误事件中，GOAWAY帧仅仅尽力尝试告诉
   对等点为什么连接会终结。

   端点可以在任何时候终止一条连接。特别是，端点可以（MAY）选择把流错误当
   做连接错误来处理。结束连接时，如果情况允许的话，端点应该（SHOULD）发
   送一个GOAWAY帧。

5.4.2.  流错误处理

   流错误是关于特定流的错误，它不会影响其他流的处理。

   检测到流错误的端点在出错的流中发送一个包含有流标识符的RST_STREAM帧
   （6.4小节）。RST_STREAM帧包含了表示错误类型的错误码。

   RST_STREAM是端点在流上发送的最后一帧。发送RST_STREAM帧的对等点必须
   （MUST）准备接受任何远程对等点发送的或者在队列里准备发送的帧。这些、
   帧可以被忽略，除非他们修改了连接的状态（比如头压缩（4.3小节）或流量
   控制的状态）。

   一般地，端点不应该（SHOULD NOT）在任何流中发送比一个RST_STREAM更多的
   帧。但是，如果在收到已关闭的流上，一个端点在超过一个往返时间以后才收
   到帧，那它可以（MAY）发送额外的RST_STREAM帧。这个行为可以处理那些不正
   确的协议实现。





Belshe, et al.               Standards Track                   [Page 29]

RFC 7540                         HTTP/2                         May 2015


   为了避免循环，端点必须不（MUST NOT）发送一个RST_STREAM作为一个
   RST_STREAM帧的响应。

5.4.3.  连接终结

   如果TCP连接已关闭或者重置，但流依然留在"open"或者"half-closed"的状态，
   那么被影响的流不能自动重试了（详细信息参看8.1.4）。

5.5.  扩展HTTP/2

   HTTP/2允许协议扩展。在本章节描述的限定的范围内，可以使用协议扩展来提供
   额外的服务或者改变协议的任何方面。扩展只能在一个单独的HTTP/2脸颊范围内
   生效。

   这适用于本文档中定义的协议元素。这不会影响现有的扩展HTTP选项，例如定义
   一个新的方法、状态码或者头域。

   扩展可以使用新的帧类型（4.1小节），新的配置（6.5.2小节），或是新的错误
   码（第7节）。注册表会管理这些扩展点：帧类型（11.2小节）、配置（11.3小节）
   和错误码（11.4小节）。

   协议实现在所有可扩展的协议元素中必须（MUST）忽略未知的或者不支持的值。
   协议实现必须（MUST）丢弃未知的或不支持的类型的帧。这就意味着即使没有实
   现安排或协商，这些扩展点中任何一个都可以安全使用。但是，在头块（4.3小节）
   中间不允许出现扩展帧；这种帧必须被当作PROTOCOL_ERROR类型的连接错误
   （5.4.1小节）处理。

   必须（MUST）在使用可能改变现有协议组件语义的扩展之前，进行协商。例如，
   改变了HEADERS帧布局的扩展不能被使用，直到其对等点给出一个能够接受的积极
   信号。这种情况下，修改的布局生效的时候，协调也是必要的。注意将除了DATA
   帧以外的其他任何帧当做流控帧处理，是一种语义上的变化，并且只能在协商中
   完成。

   本文档没有限定一种方法来协商扩展的使用，但注意一个配置（6.5.2小节）可以
   用来达到这个目的。如果两个对等点都设置了一个值，表示愿意使用这个扩展，
   那么这个扩展就能被使用。如果一个配置用作扩展协商，那么它的初始值必须
   （MUST）定义成扩展一开始是禁用的样子。



Belshe, et al.               Standards Track                   [Page 30]

RFC 7540                         HTTP/2                         May 2015



6.  帧定义

   本规范定义了若干帧类型，每一种用一个唯一的8位的类型码来标识。在建立和
   管理整个连接或者单独的流的时候，每种帧类型都为不同目的服务。

   传送特定的帧类型可以改变连接的状态。如果端点无法维护一个连接状态同步的
   视图，那么再也无法在这条连接里通行。因此，端点对于任何给定的帧是如何影
   响状态的是否达成共识这一点很重要。

6.1.  DATA帧

   DATA帧（类型=0x0）传递某一流的任意的、变长的字节序列。例如，使用一个或
   多个DATA帧来传送HTTP请求和响应的载荷。

   DATA帧也可以（MAY）包含填充。填充可以加到DATA帧中来模糊消息的大小。填充
   是一种安全特性；参看10.7小节。

    +---------------+
    |Pad Length? (8)|
    +---------------+-----------------------------------------------+
    |                            Data (*)                         ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                       图 6: DATA帧载荷

   DATA帧包含下列字段：

   Pad Length：一个表示包括帧填充在内的以字节为单位的长度的8位字段。
      该字段视情况而定（图表中用"?"标出）并且只有设置了PADDED标记的情
      况下才会有该字段。

   Data：应用数据。数据量是帧载荷减去其他域的剩余长度。



Belshe, et al.               Standards Track                   [Page 31]

RFC 7540                         HTTP/2                         May 2015


   Padding：不包含应用语义值的填充字节。填充字节必须（MUST）在发送时设置
      为零。接收方没有必要验证填充但也可以（MAY）把非零的填充当做
      PROTOCOL_ERROR类型的连接错误（5.4.1小节）处理。

   DATA帧定义了以下标记：

   END_STREAM（0x1）：设置以后，第0位表示此帧是端点在这条流上将发送的最后
      一帧。设置这个标记会使流进入"half-closed"状态中的一种或者是"closed"
      状态（5.1小节）。

   PADDED (0x8):  设置以后, 第3位表示存在Pad Length字段和它所表示的填充。

   DATA帧必须（MUST）关联到某一流上。如果收到的DATA帧的流标识符字段是0x0，
   接收方必须（MSUT）响应一个PROTOCOL_ERROR类型的连接错误（5.4.1）小节。

   DATA帧受流量控制限制并且只能在"open"和"half-closed (remote)"状态下的流
   中发送。流量控制包括整个DATA帧的载荷，Pad Length和Padding字段如果有都
   算在内。如果接收DATA帧的流不是"open"或"half-closed (local)"状态，接收方
   必须（MUST）响应一个STREAM_CLOSED类型的流错误（5.4.2小节）。

   填充字节的总数取决于Pad Length字段的值。如果填充的长度等于或超过载荷的
   长度，接收方必须（MUST）当作一个PROTOCOL_ERROR类型的连接错误（5.4.1小节）
   处理。

      注意：可因等于零的Pad Length字段导致帧的大小增加一个字节。

6.2.  HEADERS

   HEADERS帧（type=0x1）用来打开一个流（5.1小节），并且还带有一个头块片段。
   HEADERS帧可以在"idle"、"reserved (local)"、"open"或"half-closed (remote)"
   状态下的流中发送。









Belshe, et al.               Standards Track                   [Page 32]

RFC 7540                         HTTP/2                         May 2015


    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |E|                 Stream Dependency? (31)                     |
    +-+-------------+-----------------------------------------------+
    |  Weight? (8)  |
    +-+-------------+-----------------------------------------------+
    |                   Header Block Fragment (*)                 ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                      图 7：HEADERS帧载荷

   HEADERS帧载荷有着以下的字段：

   Pad Length：一个表示包括帧填充在内的以字节为单位的长度的8位字段。此
      字段只有在设置PADDED标记时才会出现。

   E：一个单二进制位的标记，表示流依赖是排他的（5.3小节）。此字段只有在
      设置PRIORITY标记时才会出现。

   Stream Dependency：一个31位的流标识符，表示本流所依赖的流5.3小节。此
      字段。只有在设置PRIORITY标记时才会出现。

   Weight：一个无符号8为整数，表示流的优先级权重（5.3小节）。该值加一以
      后就获取到一个1到256的权重。此字段只有在设置PRIORITY标记时才会出现。

   Header Block Fragment：头块片段（4.3小节）。

   Padding：填充字节。

   HEADERS帧定义了以下标记：

   END_STREAM（0x1）：设置以后，第0位表示头块（4.3小节）是端点为此流发送
      的最后一个。

      带有END_STREAM标记的HEADERS帧表示流的结束。但是，带有END_STREAM标记
      的HEADERS帧在同一流中可以后接CONTINUATION帧。逻辑上，CONTINUATION帧
      是HEADERS帧的一部分。




Belshe, et al.               Standards Track                   [Page 33]

RFC 7540                         HTTP/2                         May 2015


   END_HEADERS（0x4）：设置以后，第2位表示此帧包含一整个头块（4.3小节）
      并且后面没有任何CONTINUATION帧。

      没有设置END_HEADERS标记的HEADERS帧必须（MUST）在同一流中后接一个
      CONTINUATION帧。接收方必须（MUST）把收到的其他类型的帧在不同流中
      当做一个PROTOCOL_ERROR类型的连接错误（5.4.1小节）处理。

   PADDED（0x8）：设置以后，第3位表示有Pad Length字段以及它所描述的填充。

   PRIORITY（0x20）：设置以后，第5位表示存在Exclusive标记（E）、Stream
      Dependency和Weight字段；参看5.3小节。

   HEADERS帧的载荷包含了一个头片段（4.3小节）。一个HEADERS帧装不下的头块
   在CONTINUATION帧中延续（6.10小节）。

   HEADERS帧必须关联于一个流。如果收到的HEADERS帧的流的标识符时0x0，那么
   接收方必须响应一个PROTOCOL_ERROR类型的连接错误（5.4.1小节）。

   4.3小节描述了HEADERS帧是改变连接状态的。

   HEADERS帧可以包含填充。填充字段和标记和DATA帧（6.1小节）定义的一模一样。
   超出头块片段剩余大小的填充必须（MUST）当作PROTOCOL_ERROR处理。

   HEADERS帧中的优先排序信息逻辑上等同于单独的PRIORITY帧，但是包含在HEADERS
   中就避免了在新流创建时流优先次序被扰乱的潜在可能性。第一个HEADERS帧随后
   的HEADERS帧中的优先排序字段会重排流（5.3.3小节）。

6.3.  PRIORITY

   PRIORITY帧（type=0x2）规定了发送方声明的流优先级（5.3小节）。它可以在任
   何流状态下发送，包括空闲和关闭的流。






Belshe, et al.               Standards Track                   [Page 34]

RFC 7540                         HTTP/2                         May 2015


    +-+-------------------------------------------------------------+
    |E|                  Stream Dependency (31)                     |
    +-+-------------+-----------------------------------------------+
    |   Weight (8)  |
    +-+-------------+

                     图 8: PRIORITY帧载荷

   PRIORITY帧的载荷包含下面字段：

   E：一个单二进制位的标记，表示流依赖是排他的（5.3小节）。

   Stream Dependency：一个31为的流标识符，表示该流依赖的流（参看5.3小节）。

   Weight：一个无符号8位整数，表示流的优先级权重（参看5.3小节）。在该值上
      加一就能获得一个从1到256的权重。

   PRIORITY帧未定义任何标记。

   PRIORITY帧总是要标识出某一流。如果在标识符为0x0的流上收到PRIORITY帧，
   接收方必须响应一个PROTOCOL_ERROR类型的流错误（5.4.1小节）。

   PRIORITY帧可以在任何状态下的流中发送，但是在包含单独的头块（4.3小节）
   的连续帧之间是不允许发送的。注意这种帧可以在帧处理或帧发送完成以后才
   到达，这会导致它在这条已标识的流上失效。对于"half-closed (remote)"或
   "closed"状态下的流，这种帧只能影响对已标识的流以及它的从属流的处理；
   它不影响流上的帧传输。

   PRIORITY帧可以在"idle"或"closed"状态下的流中发送。通过修改未使用的或
   关闭的父流的优先级可以重排一组从属流。

   非5字节的PRIORITY帧必须（MUST）当作FRAME_SIZE_ERROR类型的流错误（5.4.2
   小节）处理。 








Belshe, et al.               Standards Track                   [Page 35]

RFC 7540                         HTTP/2                         May 2015


6.4.  RST_STREAM

   RST_STREAM帧（type=0x3）可以马上终结一条流。发送RST_STREAM来请求把流
   取消或者表示一种错误情形已经发生。

    +---------------------------------------------------------------+
    |                        Error Code (32)                        |
    +---------------------------------------------------------------+

                    图 9: RST_STREAM帧载荷

   RST_STREAM帧包括一个单独的无符号的标识错误码（第7节）的32位整数。错误
   码表示为什么流被终结了。

   RST_STREAM帧没有定义任何标记。

   RST_STREAM帧完全终结相关流并且使其进入"closed"状态。在流上接收到
   RST_STREAM以后，接收方必须不（MUST NOT）再给流发送额外的帧，除了
   PRIORITY以外。但是，发送RST_STREAM以后，发送端点必须（MUST）准备接收
   并处理对等点可能在RST_STREAM到达之前已经发送的这条流上的额外帧。

   RST_STREAM帧必须（MUST）关联到一条流上。如果收到流标识符为0x0的
   RST_STREAM帧，接收方必须（MUST）当作PROTOCOL_ERROR的连接错误（5.4.1小
   节）处理。

   RST_STREAM帧必须不（MUST NOT）在"idle"状态下的流中发送。如果在空闲流上
   收到RST_STREAM帧，接收方必须（MUST）当作PROTOCOL_ERROR的连接错误
   （5.4.1小节）处理。

   非4字节的RST_STREAM帧必须（MUST）被当作FRAME_SIZE_ERROR类型的连接错误
   （5.4.1小节）处理。

6.5.  SETTINGS

   SETTINGS帧（type=0x4）传输影响端点通信方式的配置参数，比如对等点行为的
   首选项和约束。SETTINGS帧也用来告知接收方已经收到这些参数。特别地，
   SETTINGS参数也可以被称作“设置参数（setting）”。





Belshe, et al.               Standards Track                   [Page 36]

RFC 7540                         HTTP/2                         May 2015


   SETTINGS参数不被协商；他们描述发送对等点的特征，这些特征会被接收对等
   点用到。任一对等点可以对同一参数声明不同的值。例如，客户端可以设置一
   个高的初始流控窗口，同时服务器可以设置一个低的值来保留资源。

   SETTINGS帧（MUST）在连接开始的时候被两个端点发送，并且可以（MAY）在连
   接的有效期内的其他任何时候被任一端点发送。协议实现必须（MUST）支持本规
   范中定义的所有参数。

   SETTINGS帧中的任何参数会替换这个参数的原有值。参数按照他们出现的顺序被
   处理，SETTINGS帧的接收方不需要维护除了参数当前值以外的任何状态。因此，
   SETTINGS参数的值为接收方最后看到的值。

   接收方确认收到SETTINGS参数。为了实现这个功能，SETTINGS定义了如下标记：

   ACK（0x1）：设置以后，第0位表示这个帧确认已经收到并应用了对等点的SETTINGS
      帧。如果设置了该位，SETTINGS帧的载荷必须（MUST）为空。接收到带有ACK
      标记但是长度字段值不是0的SETTINGS帧，必须（MUST）当作FRAME_SIZE_ERROR
      类型的连接错误（5.4.1小节）处理。获取更多信息，参看6.5.3小节（配置
      同步）。

   SETTINGS帧总是应用于某条连接，而不是一条流。SETTINGS帧的流标识符必须为零
   （0x0）。如果端点收到流标识符字段不是0x0的SETTINGS帧，端点必须（MUST）响
   应一个PROTOCOL_ERROR类型的连接错误（5.4.1小节）。

   SETTINGS帧会影响连接状态。格式错误或者不完整的SETTINGS帧必须被当作
   PROTOCOL_ERROR类型的连接错误（5.4.1小节）处理。

   不是6的倍数个字节的SETTINGS帧必须（MUST）被当做FRAME_SIZE_ERROR类型的连接
   错误（5.4.1小节）处理。









Belshe, et al.               Standards Track                   [Page 37]

RFC 7540                         HTTP/2                         May 2015


6.5.1.  SETTINGS帧格式

   SETTINGS帧的载荷包含一个或多个参数，每个参数包含一个无符号16位的设
   置标识符以及一个无符号32位的值。

    +-------------------------------+
    |       Identifier (16)         |
    +-------------------------------+-------------------------------+
    |                        Value (32)                             |
    +---------------------------------------------------------------+

                         图 10：SETTINGS帧格式

6.5.2.  定义SETTINGS参数

   定义了如下参数：

   SETTINGS_HEADER_TABLE_SIZE（0x1）：允许发送方告诉远程端点用来解码头
      块的头压缩表的最大长度，单位字节。通过使用专门针对头块中头压缩格
      式的信号机制（参看[COMPRESSION]），编码器可以选择任何小于等于该值
      的大小。初始值是4,096个字节。

   SETTINGS_ENABLE_PUSH（0x2）：此配置可以用来禁用服务器推送（8.2小节）。
      如果端点收到这个参数，其值为0，端点必须不（MUST NOT）发送一个
      PUSH_PROMISE帧。已经将参数设置为0并且确认以后的端点必须（MUST）把
      收到PUSH_PROMISE帧当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）处
      理。

      初始值是1，表示允许服务器推送。任何不是0或1的值必须（MUST）被当做
      PROTOCOL_ERROR类型的连接错误（5.4.1小节）处理。

   SETTINGS_MAX_CONCURRENT_STREAMS（0x3）：表示发送方允许的当前流的最大
      数目。这个限制是单向的：它应用于发送方允许接收方创建的流的个数。初
      始地，该值没有任何限制。建议该值别小于100，避免不必要的并行限制。

      值为0SETTINGS_MAX_CONCURRENT_STREAMS应该不（SHOULD NOT）被端点当作
      特殊情况处理。零值的确会阻止新流的创建；但是，这也会发生在任何被流
      耗尽的限制参数上。服务器应该（SHOULD）只在短时间内设置为0；如果服务
      器不想接收请求，更合适的做法是关闭连接。




Belshe, et al.               Standards Track                   [Page 38]

RFC 7540                         HTTP/2                         May 2015



   SETTINGS_INITIAL_WINDOW_SIZE（0x4）：表示用作流层的流控发送方初始
      窗口大小（单位：字节），用作流层的流控。初始值是2^16-1（65,535）
      字节。

      这个设置影响所有流的窗口大小（6.9.2小节）。

      比流控窗口大小上限2^31-1的值必须（MUST）被当作FLOW_CONTROL_ERROR
      类型的流错误（5.4.1小节）处理。

   SETTINGS_MAX_FRAME_SIZE（0x5）：表示发送方愿意接收的最大帧载荷的大小，
      以字节为单位。

      初始值是2^14（16,384）字节。端点声明的值必须（MUST）在初始值和帧
      大小的最大值（2^24-1或16,777,215字节）之间，包括边界。在这个范围
      以外的值必须（MUST）被当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）
      处理。

   SETTINGS_MAX_HEADER_LIST_SIZE（0x6）：这个建议的设置告诉对等点，发送
      方准备接收的头列表的最大长度，单位字节。该值基于未压缩的头域大小，
      包括名字和值的字节长度加上每个头域额外的32字节。

      对于任意给定请求，可以（MAY）使用比声明的值更低的限制。这个配置的
      初始值是未限制的。

   接收到还有任何未知或者不支持的标识符的SETTINGS帧的端点必须（MUST）忽
   略该设置。

6.5.3.  设置的同步

   SETTINGS中的大部分值受益于或者需要对对等点何时收到并且应用了已修改的
   参数值的理解。为了提供这样的同步时间点，没有ACK标记的SETTINGS帧的接收
   方必须（MUST）在收到后尽快应用更新后的参数。

   SETTINGS帧的值必须（MUST）按照它们出现的顺序被处理，它们之间不允许有
   其他的帧处理。不被支持的参数必须（MUST）被忽略。一旦所有值都被处理了，
   接收方必须（MUST）立即发送一个设置有ACK标记的SETTINGS帧。一收到设置
   有ACK标记的SETTINGS帧，变动参数的发送方可以相信该设置已经被应用了。



Belshe, et al.               Standards Track                   [Page 39]

RFC 7540                         HTTP/2                         May 2015



   如果SETTINGS帧的发送方没有在合理的时间内收到确认信息，它可以（MAY）
   提出一个SETTINGS_TIMEOUT类型的连接错误（5.4.1小节）。

6.6.  PUSH_PROMISE

   PUSH_PROMISE帧（type=0x5）用作事先通知对等端点，发送方试图初始化流。
   PUSH_PROMISE帧包括端点计划要创建的流的无符号31位标识符还有一些提供附
   加的流上下文的头。8.2小节中从头到尾描述了PUSH_PROMISE帧的使用。

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |R|                  Promised Stream ID (31)                    |
    +-+-----------------------------+-------------------------------+
    |                   Header Block Fragment (*)                 ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                  图 11: PUSH_PROMISE帧的载荷格式

   PUSH_PROMISE帧的载荷有下面的字段：

   Pad Length：一个8位字段包含了帧填充的长度，以字节为单位。此字段只有
      在PADDED标识被设置的时候才会出现。

   R：一个保留的二进制位。

   Promised StreamID：一个无符号31位整数，标识PUSH_PROMISE预留出的流。
      发送方发送的被允诺的流标识符必须（MUST）是一个可用于下一条流的值。
      （参看5.1.1小节中的“新流的标识符”）。

   Header Block Fragment：一个含有请求头域的头块片段（4.3小节）。

   Padding：填充字节。




Belshe, et al.               Standards Track                   [Page 40]

RFC 7540                         HTTP/2                         May 2015


   PUSH_PROMISE帧定义以下的标记：

   END_HEADERS（0x4）：设置以后，第2位表示这个帧包含一整个头块（4.3小节）
      后续没有CONTINUATION帧。

      没有设置END_HEADERS标记的PUSH_PROMISE帧必须（MUST）在同一流中后接
      一个CONTINUATION帧。收到任何其他类型的帧或者从别的流中收到帧，接收
      方必须（MSUT）都当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）处理。

   PADDED（0x8）：设置以后，第3位表示存在Pad Length字段及其描述的填充。

   PUSH_PROMISE帧必须（MUST）只能在"open"或"half-closed (remote)"状态下
   的流中发送。PUSH_PROMISE帧的流标识符表示其所关联的流。如果流标识符字
   段的值指定为0x0，接收方必须（MUST）响应一个PROTOCOL_ERROR类型的流连接
   错误（5.4.1小节）。

   不要求按照被允诺的顺序来使用被允诺的流。PUSH_PROMISE只是预留出流标识符
   以备将来使用。

   PUSH_PROMISE必须不（MUST NOT）能在对等端点的SETTINGS_ENABLE_PUSH设置
   为0的时候发送。如果端点有此设置，并且收到了确认，那么必须把接收到
   PUSH_PROMISE帧的情况当作PROTOCOL_ERROR类型的流连接错误（5.4.1小节）。

   PUSH_PROMISE帧的接收方可以选择返回给PUSH_PROMISE帧的发送方一个带有被
   允诺的流的标识符的RST_STREAM来拒绝被允诺的流。

   PUSH_PROMISE帧通过两种方式修改连接状态。首先，其中的头块（4.3小节）默
   认地修改了被偷压缩维护的状态。其次，PUSH_PROMISE为将来使用预留了一条流，
   使得被允诺的流进入"reserved"状态。除非流在"open"或"half-closed (remote)"
   状态下，发送方必须不（MUST NOT）能在这条流上发送PUSH_PROMISE；发送方必
   须（MUST）保证被允诺的流有个一有效的新流标识符（5.1.1小节）（也就是，
   被允诺的流必须（MUST）处于"idle"状态）。






Belshe, et al.               Standards Track                   [Page 41]

RFC 7540                         HTTP/2                         May 2015


   PUSH_PROMISE帧预留出了一条流，那么忽略PUSH_PROMISE帧的话会导致流状态
   变得模糊。在既非"open"也非"half-closed (local)"状态的流上收到
   PUSH_PROMISE帧，接收者必须（MUST）当作PROTOCOL_ERROR类型的流连接错误
   （5.4.1小节）处理。但是，在关联流上发送了RST_STREAM的端点必须（MUST）
   在收到和处理RST_STREAM帧之前处理可能已经被创建的PUSH_PROMISE帧。

   如果收到的PUSH_PROMISE帧所允诺的流标识符非法，接收方必须（MUST）当作
   一个PROTOCOL_ERROR类型的流连接错误（5.4.1小节）。注意非法的流标识符
   指的是这个标识符下的流当前不是"idle"状态。

   PUSH_PROMISE帧可以包含填充。填充域和标记和为DATA帧（6.1小节）定义的一
   模一样。

6.7.  PING

   PING帧（type=0x6）是一种机制用来处理一个从发送方开始的最小的往返时间，
   也用来确定空闲连接是否仍然可用。任意一端端点都可以发送PING帧。

    +---------------------------------------------------------------+
    |                                                               |
    |                      Opaque Data (64)                         |
    |                                                               |
    +---------------------------------------------------------------+

                      图 12: PING帧载荷的格式

   除了帧头，PING帧必须（MUST）包含载荷中的8字节不透明数据。发送方可以
   选择任意值并以任何形式使用这些字节。

   没有ACK标记的PING帧的接收方必须（MUST）在响应中发送一个带ACK标记的
   的PING帧，载荷和之前收到的PING帧一模一样。PING响应应该（SHOULD）被
   赋予一个比其他任何帧都高的优先级。

   PING帧定义了以下标记：

   ACK（0x1）：设置以后，第0位表示这个PING帧时一个PING响应。端点必须
      （MUST）在PING响应中设置此标记。端点必须不（MUST NOT）响应PING
      帧。端点必须不（MUST NOT）响应包含此标记的PING帧。




Belshe, et al.               Standards Track                   [Page 42]

RFC 7540                         HTTP/2                         May 2015


   PING帧和任何一条单独的流都无关。如果收到有非0x0流标识符字段值的PING
   帧，接收方必须响应一个PROTOCOL_ERROR类型的流错误（5.4.1小节）。

   收到长度字段不是8的PING帧必须被当作类型的流错误（5.4.1小节）处理。 

6.8.  GOAWAY

   GOAWAY帧（type=0x7）用来发起一个连接的关闭或者表示严重的错误情形。
   GOAWAY允许端点优雅地停止接收新流，同时仍会完成之前建立的流的处理。这
   就允许例如服务器维护之类的管理动作。

   在端点发起新流和远程端点发送GOAWAY帧之间有着天生的竞争条件。为了应对
   这种情形，GOAWAY帧包含对等点最近初始化的流的标识符，该流被或有可能被
   发送端点处理。举个例子，如果服务器发送一个GOAWAY帧，被标识的流就是客
   户端初始化的数字最大的那个流。

   一旦被发送，发送方会忽略接收方初始化的标识符大于最近流标识符的流中的
   帧。GOAWAY帧的接收方必须不（MUST NOT）在该连接上打开额外的流，尽管可
   以为了新流而新建连接。

   如果GOAWAY的接收方已经在高于GOAWAY帧中流标识符的流中收到数据，那么这
   些流不会等到处理。GOAWAY帧的接收方可以把这些流当作从没创建过一样，从
   而允许在新连接中重试这些流。

   端点应该（SHOULD）总是在关闭一条连接之前发送GOAWAY帧，这样远程对等点
   能够知道流是否被部分处理。例如，如果一个HTTP客户端在服务器关闭连接的
   同时发送一个POST请求，服务器不发送GOAWAY帧来表示它已经在处理哪些流的
   话，客户端就不能够知道服务器是否开始处理这个POST请求。

   对出错的对等点，端点可以选择不发送GOAWAY帧就关闭连接。



Belshe, et al.               Standards Track                   [Page 43]

RFC 7540                         HTTP/2                         May 2015


   GOAWAY帧发送后也许不会立即关闭连接；GOAWAY帧的接收方仍应该（SHOULD）
   在关闭不再使用的连接之前，发送一个GOAWAY帧。

    +-+-------------------------------------------------------------+
    |R|                  Last-Stream-ID (31)                        |
    +-+-------------------------------------------------------------+
    |                      Error Code (32)                          |
    +---------------------------------------------------------------+
    |                  Additional Debug Data (*)                    |
    +---------------------------------------------------------------+

                     图 13：GOAWAY载荷的格式

   GOAWAY帧没定义任何标记。

   GOAWAY帧应用于连接，而不是一个特定的流。端点必须把含有非0x0流标识符
   的GOAWAY帧当作PROTOCOL_ERROR类型的连接错误（5.4.1小节）处理。

   GOAWAY帧中的最近流标识符含有其发送方已经或者也许正在处理的数字最大的
   流标识符。包括自身在内所有的不大于该标识符的流可能已经以某种方式被处
   理。如果没有流被处理过，最近流标识符可以设置为0。

      注意：在这种环境下，“被处理”的意思是从这条流上传递到软件更高层的
      数据也许已经因此有所行动。

   如果没有GOAWAY帧而连接终结，那么最近流标识符实际上是允许的最大流标识
   符。

   在标识符数字小于等于连接关闭之前还没完全关闭的流的流上，无法重试请求、
   事务或者任何协议活动，除了幂等操作以外，比如HTTP的GET、PUT或DELETE方
   法。任何使用数字更大的流的的协议活动可以使用新连接来安全重试。

   小于等于最近流标识符的流上的活动仍可以成功地完成。GOAWAY帧的发送方可
   以发送一个GOAWAY来优雅地关闭一条连接，同时维持连接在"open"状态知道所
   有处理中的流都完成。



Belshe, et al.               Standards Track                   [Page 44]

RFC 7540                         HTTP/2                         May 2015


   如果环境改变，端点可以（MAY）发送多个GOAWAY帧。比如，发送含有NO_ERROR
   的GOAWAY帧的端点在优雅关闭期间可能随后遇到一种要求连接立即终结的情况。
   来自收到的最后一个GOAWAY帧的最近流标识符指出了可以哪些流上操作。端点
   必须不（MUST NOT）增加他们所发送的最近流标识符的值，因为对等点也许已
   经在另一连接上重试了没有得到的处理的请求。

   不能重试请求的客户端会丢失所有服务器关闭连接时还在传输途中的请求。对可
   能不服务于使用HTTP/2协议的客户端的中介来说，尤是如此。试图优雅关闭连接
   的服务器应该（SHOULD）发送一个带有设置为2^31-1的最近流标识符以及一个
   NO_ERROR码的初始GOAWAY帧。这会发信给客户端，连接马上关闭并且不再允许发
   起请求。在允许用来创建传输途中的流的时间（至少一个往返时延）过后，服务
   器可以发送另一个带有新最近流标识符的GOAWAY帧。这就保证了连接被干净地关
   闭，不会丢失请求。

   发送GOAWAY帧以后，发送方可以丢弃在那些接收方初始化的标识符大于最近流标
   识符的流上的帧。但是，任何修改流状态的帧不能被完全忽略。例如，HEADERS、
   PUSH_PROMISE和CONTINUATION帧必须（MUST）被最低限度地使用来保证为头压缩
   维护的状态一致（参看4.3小节）；相似地，DATA帧必须（MUST）被计入连接流
   控窗口。对这些帧的处理的失败可导致流控或头压缩状态变得不同步。

   GOAWAY帧也包含了一个32位的错误码（Section 7），错误码包含了流关闭的原因。

   端点可以（MAY）把不透明数据加到任何GOAWAY帧的载荷中。附加调试数据仅仅为
   了诊断目的并且没携带任何语义值。调试信息可以包含安全性的或者隐私敏感的
   数据。日志记录的或者持久存储的数据必须（MUST）具备足够的安全措施来防止
   未授权的访问。










Belshe, et al.               Standards Track                   [Page 45]

RFC 7540                         HTTP/2                         May 2015


6.9.  WINDOW_UPDATE

   WINDOW_UPDATE帧（type=0x8）用来实现流量控制；总体概述参看5.2小节。

   流量控制在两个层面上操作：在每一个单独流上以及在整个连接上。

   两种类型的流量控制都是逐跳的，也就是，只会在两个端点间控制。中介不会
   在两条独立的连接之间转发WINDOW_UPDATE帧。但是，接收方对数据传输的节
   流都会间接地导致流控信息传导到发送方。

   流量控制只应用于被标识为受流量控制的帧。本文档中定义的帧类型中，只有
   DATA 帧在此范围内。免于流量控制的帧必须（MUST）接收并处理，除非接收方
   分配不到资源来处理帧。如果接收方不能再接受帧，它可以（MAY）响应一个
   FLOW_CONTROL_ERROR类型的流错误（5.4.2小节）或连接错误（5.4.1小节）。

    +-+-------------------------------------------------------------+
    |R|              Window Size Increment (31)                     |
    +-+-------------------------------------------------------------+

                  图 14：WINDOW_UPDATE载荷格式

   WINDOW_UPDATE帧的载荷是一个保留位加上一个无符号31位整数，这个整数表示
   发送方还能在现有流控窗口中发送的字节数。流控窗口增量的合法范围是1到
   2^31-1（2,147,483,647）字节。

   WINDOW_UPDATE帧不会定义任何标记。

   WINDOW_UPDATE帧具体可以指一条流或者只整条连接。在前者条件下，帧的流标
   识符表示会影响到的流；在后者情形下，“0”值表示整条连接都是帧的影响对象。

   收到流控窗口增量为0的WINDOW_UPDATEA帧，接收方必须（MUST）将其当作
   PROTOCOL_ERROR类型的流错误（5.4.2小节）；连接流控窗口的错误必须（MSUT）
   被当作连接错误处理（5.4.1小节）。





Belshe, et al.               Standards Track                   [Page 46]

RFC 7540                         HTTP/2                         May 2015


   WINDOW_UPDATE帧可以被已经发送过带有END_STREAM标记的帧的对等点发送。
   这就意味着接收方可以在"half-closed (remote)"或"closed"状态下的流上
   接收WINDOW_UPDATE帧。接收方必须不（MUST NOT）将此当作错误（5.1小节）
   处理。

   接收被流控限制的帧的接收方必须（MUST）总是将其大小计入流控窗口，除
   非接收方将其当作连接错误（5.4.1小节）处理。即使帧是错误的也有必要
   这么做。发送方吧帧计入流控窗口，但如果接收方不计入的话，那么发送方
   和接收方之间的流控窗口就可能变得不同。

   非4字节的WINDOW_UPDATE帧必须（MUST）被当作FRAME_SIZE_ERROR类型的连
   接错误（5.4.1小节）处理。

6.9.1.  流控窗口

   HTTP/2中的流量控制的实现是使用一个窗口，所有流上的每个发送方都必须维
   护这个窗口。流控窗口是一个简单的整数值，表示允许发送方传输多少个字节；
   这样，它的大小就可以衡量出接收方的缓冲区容量。

   有两种流控窗口：流的流控窗口和连接的流控窗口。对于接收方告知的无论哪
   种流控窗口而言，发送方必须不（MUST NOT）发送一个长度超出可用空间的流
   控帧。如果两种窗口都没有可用空间了，设有END_STREAM标记的零长度的帧
   （也就是，空的DATA帧）还是可以（MAY）发送的。

   流控计算时，9字节的帧头不被计入。

   发送完流控帧以后，发送方按传输帧的长度在两种窗口中一起减去可用空间。

   如果一个帧的接收方消耗了数据并且释放了流控窗口的空间。要分别发送流层
   和连接层的流控窗口的WINDOW_UPDATE帧。

   发送方收到一个WINDOW_UPDATE帧后，用帧中定义的数量来升级对应窗口。





Belshe, et al.               Standards Track                   [Page 47]

RFC 7540                         HTTP/2                         May 2015


   发送方必须不（MUST NOT）允许流控窗口超过2^31-1字节。如果发送方收到回
   导致流控窗口超出最大值的WINDOW_UPDATE帧，它必须（MUST）终止相应的流
   或连接。终止流时，发送方发送一个带有FLOW_CONTROL_ERROR错误码的
   RST_STREAM帧；终止连接时，发送一个带有FLOW_CONTROL_ERROR错误码的
   GOAWAY帧。

   来自于发送方受流控的帧和来自于接收方WINDOW_UPDATE帧，相互之间是完全异
   步的。这个属性允许接收方激进地升级发送方维护的窗口大小，以防流停止。

6.9.2.  初始的流控窗口大小

   HTTP/2连接初次建立时，新流的初始流控窗口大小为65,535字节。连接的流
   控窗口大小也是65,535字节。通过作为连接开端组成部分的包含
   SETTINGS_INITIAL_WINDOW_SIZE值的SETTINGS帧，两端端点可以为新流调整
   初始窗口大小。连接流控窗口只能使用WINDOW_UPDATE来修改。

   接收设置有SETTINGS_INITIAL_WINDOW_SIZE的SETTINGS帧之前，端点发送受
   流控的帧时只能使用默认的初始窗口大小。相似地，连接流控窗口也被设置
   为默认初始窗口大小，直到收到WINDOW_UPDATE帧。

   除了修改还未激活的流的流控窗口以外，SETTINGS帧还能改变已有活动流控
   窗口的流的初始流控窗口大小（就是那些处在"open"或"half-closed (remote)"
   状态下的流）。当SETTINGS_INITIAL_WINDOW_SIZE的值改变时，接收方必须（
   MUST）根据其维护的新旧值的差来调整所有流控窗口的大小。

   SETTINGS_INITIAL_WINDOW_SIZE的改变能够导致流控窗口中的可用空间变成负的。
   发送方必须（MUST）跟踪负的流控窗口并且必须不（MUST NOT）发送新的流控帧直
   到它收到把流控窗口变成正的WINDOW_UPDATE帧为止。

   举个例子，如果客户端在连接创建时立即发送60KB并且服务端设置初始窗口大小为16KB，
   客户端一收到SETTINGS帧会重新计算可用流控窗口为-44KB。客户端保留一个负的流控
   状况直到WINDOW_UPDATE帧将窗口重置为正的，在这之后客户端可以继续发送。





Belshe, et al.               Standards Track                   [Page 48]

RFC 7540                         HTTP/2                         May 2015



   SETTINGS帧不能改变连接的流控窗口。 

   如果SETTINGS_INITIAL_WINDOW_SIZE帧的改变导致流控窗口超过最大值，端点
   必须（MUST）将其处理为一个FLOW_CONTROL_ERROR类型的连接错误（5.4.1小节）。

6.9.3.  减少流控窗口大小

   接收方如果希望使用一个比当前大小更小的初始流控窗口，可以发送一个新的
   SETTINGS帧。但是，接收方必须（MUST）准备接收超过这个窗口大小的数据，
   因为发送方也许在处理SETTINGS帧之前，发送了超过这个较低限制的数据。

   发送了减少初始流控窗口大小的SETTINGS帧以后，接收方可以（MAY）继续处理
   超过流控限制的流。允许流继续意味着不允许接收方立即它为降低流控窗口保留
   的空间。对这些流的处理也可以先放一放，因为需要WINDOW_UPDATE帧来允许发
   送方继续发送。对于受到影响的流，接收方也可以（MAY）选择发送一个包含
   FLOW_CONTROL_ERROR错误码的RST_STREAM帧。

6.10.  CONTINUATION

   CONTINUATION帧(type=0x9)用来继续发送头块片段序列。（4.3小节）可以发送
   任何数量的CONTINUATION帧，只要前面的帧在同一流上并且为不设有END_HEADERS
   标识的HEADERS、PUSH_PROMISE或CONTINUATION帧。

    +---------------------------------------------------------------+
    |                   Header Block Fragment (*)                 ...
    +---------------------------------------------------------------+

                   Figure 15: CONTINUATION Frame Payload

   CONTINUATION帧的载荷由一个头块片段组成（4.3小节）。








Belshe, et al.               Standards Track                   [Page 49]

RFC 7540                         HTTP/2                         May 2015


   CONTINUATION帧定义了以下标识：

   END_HEADERS (0x4):  设置以后，倒数第二位表示这个帧是一个头块的结束（
      4.3小节）。

      如果没有设置END_HEADERS位，此帧必须（MUST）后接另一个CONTINUATION
      帧。接收方收到其他类型帧或者其他流上的帧，必须（MUST）当作PROTOCOL_ERROR
      类型的连接错误（5.4.1节）处理。

   CONTINUATION帧像4.3节中定义的那样改变连接的状态。

   CONTINUATION必须和一条流关联。如果收到流标识字段是0x0的CONTINUATION帧，
   接收方必须响应一个PROTOCOL_ERROR类型的连接错误（5.4.1节）。

   CONTINUATION帧必须跟在未设置END_HEADERS标记的HEADERS、PUSH_PROMISE或者
   CONTINUATION帧的后面。接收方若观察到违反该规则的行为，必须（MUST）响应
   一个PROTOCOL_ERROR类型的连接错误（5.4.1节）。

7.  错误码

   错误码是32位字段，用在RST_STREAM和GOAWAY帧中，用来表示流或连接错误的原
   因。

   错误码共享一个普通的码空间。一些错误码只应用于流或者整条连接，并且在
   其他语境中没有语义定义。

   定义以下的错误码：

   NO_ERROR (0x0)：相关状态不是错误结果。例如，一个GOAWAY帧会包含这个代码，
      来表示优雅地关闭连接。

   PROTOCOL_ERROR (0x1)：端点检测到一个不确定的协议错误。在没有明确的可用
      错误码时，就可以用这个错误。

   INTERNAL_ERROR (0x2)：端点遇到一个预期之外的内部错误。

   FLOW_CONTROL_ERROR (0x3)：端点检测到它的对等点违反了流控协议。




Belshe, et al.               Standards Track                   [Page 50]

RFC 7540                         HTTP/2                         May 2015


   SETTINGS_TIMEOUT (0x4)：端点发送SETTINGS帧但是未及时收到响应。请看6.5.3
      节（设置的同步）。

   STREAM_CLOSED (0x5)：端点在流半关闭的状态下接收到帧。

   FRAME_SIZE_ERROR (0x6)：端点接收到的帧的大小不合法。

   REFUSED_STREAM (0x7)：端点在执行任何应用处理（详情见8.1.4节）之前拒绝流。

   CANCEL (0x8)：端点表示不在需要这条流。

   COMPRESSION_ERROR (0x9)：端点不能为连接维护头压缩上下文。

   CONNECT_ERROR (0xa)：CONNECT请求（8.3节）的响应中建立的连接被重置或非正
      常关闭。

   ENHANCE_YOUR_CALM (0xb)：端点检测到其对等点表现出可能导致过载的行为。

   INADEQUATE_SECURITY (0xc)：底层传输的属性不满足最小安全要求（请看9.2节）。

   HTTP_1_1_REQUIRED (0xd)：端点要求使用HTTP/1.1代替HTTP/2。

   未知的或者不被支持的错误码必须不（MUST NOT）触发任何特殊行为。实现方可以
   （MAY）将这些错误和INTERNAL_ERROR同等对待。

8.  HTTP 消息交换

   HTTP/2要尽量兼容当前的HTTP用户。这就意味着，从应用程序角度来看，协议
   的特性大部分不会改变。为了达到这个目的，要保留所有的请求和响应语义，
   尽管表达那些语义的语法已经发生变化。

   因此，HTTP/1.1的规范和要求，包括语义和内容[RFC7231]、条件请求[RFC7232]
   范围请求[RFC7233]、缓存[RFC7234]以及认证[RFC7235]，也适用于HTTP/2。
   HTTP/1.1消息语法和路由[RFC7230]的选定部分，比如HTTP和HTTPS URI模式，
   也适用于HTTP/2，而本协议的那部分语义由下面章节定义。



Belshe, et al.               Standards Track                   [Page 51]

RFC 7540                         HTTP/2                         May 2015



8.1.  HTTP 请求/响应交换

   客户端在新的流上发送HTTP请求，使用一个之前没有用过的流标识符（5.1.1
   节）。服务端在请求的同一条流上发送HTTP响应。

   HTTP消息（请求或响应）包含：

   1.  仅对响应而言，零个或者更多的HEADERS帧（每一个都后接零个或更多的
       CONTINUATION帧），这些HEADERS帧含有通知性的（1xx）HTTP响应头。（
       请看[RFC7230]3.2节和[RFC7231]6.2节，

   2.  一个HEADERS帧（后接零个或更多的CONTINUATION帧），这个HEADERS帧
       含有消息头（请看[RFC7230]3.2节），

   3.  零个或更多的DATA帧，这些DATA帧含有载荷体（请看[RFC7230]3.3节），

   4.  作为一个可选项，一个HEADERS帧，后接零个或更多的CONTINUATION帧，
       如果有，也包括拖挂部分（trailer-part）（请看[RFC7230]4.1.2节）。

   序列中的最后一帧带有END_STREAM标记，在任何带有头块剩余部分的CONTINUATION
   帧的后面，只能有带着END_STREAM标记的HEADERS帧。

   （在任何流中）HEADERS帧和其后可能跟随的CONTINUATION帧之间，必须不
   （MUST NOT）能出现任何其他的帧。

   HTTP/2使用DATA帧来携带消息载荷。[RFC7230] 4.1节中定义的"chunked"
   传输编码不能用在HTTP/2中。

   如果结尾的头域在一个头块中，这个头块也会终结此流。这样一个头块是一个序列，
   以HEADERS帧开头，后接零个或多个CONTINUATION帧，其中HEADERS帧带有一个
   END_STREAM标记。第一个头块不会将流终结，并且其后的头块都不是HTTP请求或
   响应的一部分。






Belshe, et al.               Standards Track                   [Page 52]

RFC 7540                         HTTP/2                         May 2015


   HEADERS帧（以及相关CONTINUATION帧）只能出现在流的开始或结尾。接收到最
   终（不含信息的）状态码后，端点若收到不带END_STREAM标记的HEADERS帧，必
   须（MUST）将相应的请求或响应当成格式不正确的（8.1.2.5节）。

   HTTP请求/响应的交换完全消耗单条流。请求以一个HEADERS帧开始，使流进入
   "open"状态。请求以一个带END_STREAM的帧结束，此帧使流变成对于客户端来说
   的"half-closed (local)"状态以及对于服务器来说的"half-closed (remote)"
   状态。响应以一个HEADERS帧开始，并且以一个带END_STREAM的帧结束，此帧会
   将流置于"closed"状态。

   服务端发送或客户端接收到设有END_STREAM标记的帧（包括一个完整头块所需的
   任何CONTINUATION帧）以后，HTTP响应就完成了。在客户端发送一整个请求之前，
   如果响应不依赖于请求还没发送或接收的部分，服务端就可以发送一个完整的响
   应。这种情形下，服务端在发送完一整个响应（也可以说是，一个带有END_STREAM
   的帧）以后，就可以（MAY）发送一个带有NO_ERROR错误码的RST_STREAM帧，来请
   求客户端无错地终止请求传输。客户端必须不（MUST NOT）因为这个RST_STREAM，
   而丢弃响应响应，但慎重起见，客户端还是一直可以为了其他原因而丢弃响应。

8.1.1.  从 HTTP/2 升级

   HTTP/2去除了101（Switching Protocols）信息状态码（[RFC7231]，6.2.2节）。

   101（Switching Protocols）的语义不适用于一个多路复用的协议。替代的协议可
   以使用HTTP/2所用的同样的机制，来协商他们的使用（请看第3节）。

8.1.2.  HTTP 头域

   HTTP头域携带了一系列键值对信息。已注册的HTTP头列表，请看“消息头域”注册表，
   维护地址：<https://www.iana.org/assignments/message-headers>。

   就像在HTTP/1.x中一样，头字段名是ASCII字符组成的字符串，并且是大小写不敏
   感的。但是，HTTP/2中，头字段名在编码之前必须（MUST）转成小写。含有大写头
   字段名请求或响应必须（MUST）被当成格式不规范的（8.1.2.6节）。



Belshe, et al.               Standards Track                   [Page 53]

RFC 7540                         HTTP/2                         May 2015


8.1.2.1.  Pseudo-Header Fields

   While HTTP/1.x used the message start-line (see [RFC7230],
   Section 3.1) to convey the target URI, the method of the request, and
   the status code for the response, HTTP/2 uses special pseudo-header
   fields beginning with ':' character (ASCII 0x3a) for this purpose.

   Pseudo-header fields are not HTTP header fields.  Endpoints MUST NOT
   generate pseudo-header fields other than those defined in this
   document.

   Pseudo-header fields are only valid in the context in which they are
   defined.  Pseudo-header fields defined for requests MUST NOT appear
   in responses; pseudo-header fields defined for responses MUST NOT
   appear in requests.  Pseudo-header fields MUST NOT appear in
   trailers.  Endpoints MUST treat a request or response that contains
   undefined or invalid pseudo-header fields as malformed
   (Section 8.1.2.6).

   All pseudo-header fields MUST appear in the header block before
   regular header fields.  Any request or response that contains a
   pseudo-header field that appears in a header block after a regular
   header field MUST be treated as malformed (Section 8.1.2.6).

8.1.2.2.  Connection-Specific Header Fields

   HTTP/2 does not use the Connection header field to indicate
   connection-specific header fields; in this protocol, connection-
   specific metadata is conveyed by other means.  An endpoint MUST NOT
   generate an HTTP/2 message containing connection-specific header
   fields; any message containing connection-specific header fields MUST
   be treated as malformed (Section 8.1.2.6).

   The only exception to this is the TE header field, which MAY be
   present in an HTTP/2 request; when it is, it MUST NOT contain any
   value other than "trailers".

   This means that an intermediary transforming an HTTP/1.x message to
   HTTP/2 will need to remove any header fields nominated by the
   Connection header field, along with the Connection header field
   itself.  Such intermediaries SHOULD also remove other connection-
   specific header fields, such as Keep-Alive, Proxy-Connection,
   Transfer-Encoding, and Upgrade, even if they are not nominated by the
   Connection header field.

      Note: HTTP/2 purposefully does not support upgrade to another
      protocol.  The handshake methods described in Section 3 are
      believed sufficient to negotiate the use of alternative protocols.



Belshe, et al.               Standards Track                   [Page 54]

RFC 7540                         HTTP/2                         May 2015


8.1.2.3.  Request Pseudo-Header Fields

   The following pseudo-header fields are defined for HTTP/2 requests:

   o  The ":method" pseudo-header field includes the HTTP method
      ([RFC7231], Section 4).

   o  The ":scheme" pseudo-header field includes the scheme portion of
      the target URI ([RFC3986], Section 3.1).

      ":scheme" is not restricted to "http" and "https" schemed URIs.  A
      proxy or gateway can translate requests for non-HTTP schemes,
      enabling the use of HTTP to interact with non-HTTP services.

   o  The ":authority" pseudo-header field includes the authority
      portion of the target URI ([RFC3986], Section 3.2).  The authority
      MUST NOT include the deprecated "userinfo" subcomponent for "http"
      or "https" schemed URIs.

      To ensure that the HTTP/1.1 request line can be reproduced
      accurately, this pseudo-header field MUST be omitted when
      translating from an HTTP/1.1 request that has a request target in
      origin or asterisk form (see [RFC7230], Section 5.3).  Clients
      that generate HTTP/2 requests directly SHOULD use the ":authority"
      pseudo-header field instead of the Host header field.  An
      intermediary that converts an HTTP/2 request to HTTP/1.1 MUST
      create a Host header field if one is not present in a request by
      copying the value of the ":authority" pseudo-header field.

   o  The ":path" pseudo-header field includes the path and query parts
      of the target URI (the "path-absolute" production and optionally a
      '?' character followed by the "query" production (see Sections 3.3
      and 3.4 of [RFC3986]).  A request in asterisk form includes the
      value '*' for the ":path" pseudo-header field.

      This pseudo-header field MUST NOT be empty for "http" or "https"
      URIs; "http" or "https" URIs that do not contain a path component
      MUST include a value of '/'.  The exception to this rule is an
      OPTIONS request for an "http" or "https" URI that does not include
      a path component; these MUST include a ":path" pseudo-header field
      with a value of '*' (see [RFC7230], Section 5.3.4).










Belshe, et al.               Standards Track                   [Page 55]

RFC 7540                         HTTP/2                         May 2015


   All HTTP/2 requests MUST include exactly one valid value for the
   ":method", ":scheme", and ":path" pseudo-header fields, unless it is
   a CONNECT request (Section 8.3).  An HTTP request that omits
   mandatory pseudo-header fields is malformed (Section 8.1.2.6).

   HTTP/2 does not define a way to carry the version identifier that is
   included in the HTTP/1.1 request line.

8.1.2.4.  Response Pseudo-Header Fields

   For HTTP/2 responses, a single ":status" pseudo-header field is
   defined that carries the HTTP status code field (see [RFC7231],
   Section 6).  This pseudo-header field MUST be included in all
   responses; otherwise, the response is malformed (Section 8.1.2.6).

   HTTP/2 does not define a way to carry the version or reason phrase
   that is included in an HTTP/1.1 status line.

8.1.2.5.  Compressing the Cookie Header Field

   The Cookie header field [COOKIE] uses a semi-colon (";") to delimit
   cookie-pairs (or "crumbs").  This header field doesn't follow the
   list construction rules in HTTP (see [RFC7230], Section 3.2.2), which
   prevents cookie-pairs from being separated into different name-value
   pairs.  This can significantly reduce compression efficiency as
   individual cookie-pairs are updated.

   To allow for better compression efficiency, the Cookie header field
   MAY be split into separate header fields, each with one or more
   cookie-pairs.  If there are multiple Cookie header fields after
   decompression, these MUST be concatenated into a single octet string
   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string "; ")
   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
   connection, or a generic HTTP server application.

   Therefore, the following two lists of Cookie header fields are
   semantically equivalent.

     cookie: a=b; c=d; e=f

     cookie: a=b
     cookie: c=d
     cookie: e=f








Belshe, et al.               Standards Track                   [Page 56]

RFC 7540                         HTTP/2                         May 2015


8.1.2.6.  Malformed Requests and Responses

   A malformed request or response is one that is an otherwise valid
   sequence of HTTP/2 frames but is invalid due to the presence of
   extraneous frames, prohibited header fields, the absence of mandatory
   header fields, or the inclusion of uppercase header field names.

   A request or response that includes a payload body can include a
   content-length header field.  A request or response is also malformed
   if the value of a content-length header field does not equal the sum
   of the DATA frame payload lengths that form the body.  A response
   that is defined to have no payload, as described in [RFC7230],
   Section 3.3.2, can have a non-zero content-length header field, even
   though no content is included in DATA frames.

   Intermediaries that process HTTP requests or responses (i.e., any
   intermediary not acting as a tunnel) MUST NOT forward a malformed
   request or response.  Malformed requests or responses that are
   detected MUST be treated as a stream error (Section 5.4.2) of type
   PROTOCOL_ERROR.

   For malformed requests, a server MAY send an HTTP response prior to
   closing or resetting the stream.  Clients MUST NOT accept a malformed
   response.  Note that these requirements are intended to protect
   against several types of common attacks against HTTP; they are
   deliberately strict because being permissive can expose
   implementations to these vulnerabilities.

8.1.3.  Examples

   This section shows HTTP/1.1 requests and responses, with
   illustrations of equivalent HTTP/2 requests and responses.

   An HTTP GET request includes request header fields and no payload
   body and is therefore transmitted as a single HEADERS frame, followed
   by zero or more CONTINUATION frames containing the serialized block
   of request header fields.  The HEADERS frame in the following has
   both the END_HEADERS and END_STREAM flags set; no CONTINUATION frames
   are sent.

     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==>     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg



Belshe, et al.               Standards Track                   [Page 57]

RFC 7540                         HTTP/2                         May 2015


   Similarly, a response that includes only response header fields is
   transmitted as a HEADERS frame (again, followed by zero or more
   CONTINUATION frames) containing the serialized block of response
   header fields.

     HTTP/1.1 304 Not Modified        HEADERS
     ETag: "xyzzy"              ==>     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = "xyzzy"
                                          expires = Thu, 23 Jan ...

   An HTTP POST request that includes request header fields and payload
   data is transmitted as one HEADERS frame, followed by zero or more
   CONTINUATION frames containing the request header fields, followed by
   one or more DATA frames, with the last CONTINUATION (or HEADERS)
   frame having the END_HEADERS flag set and the final DATA frame having
   the END_STREAM flag set:

     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==>     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :path = /resource
     {binary data}                        :scheme = https

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}

   Note that data contributing to any given header field could be spread
   between header block fragments.  The allocation of header fields to
   frames in this example is illustrative only.

   A response that includes header fields and payload data is
   transmitted as a HEADERS frame, followed by zero or more CONTINUATION
   frames, followed by one or more DATA frames, with the last DATA frame
   in the sequence having the END_STREAM flag set:







Belshe, et al.               Standards Track                   [Page 58]

RFC 7540                         HTTP/2                         May 2015


     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}

   An informational response using a 1xx status code other than 101 is
   transmitted as a HEADERS frame, followed by zero or more CONTINUATION
   frames.

   Trailing header fields are sent as a header block after both the
   request or response header block and all the DATA frames have been
   sent.  The HEADERS frame starting the trailers header block has the
   END_STREAM flag set.

   The following example includes both a 100 (Continue) status code,
   which is sent in response to a request containing a "100-continue"
   token in the Expect header field, and trailing header fields:

     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==>     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-length = 123
     123                                  content-type = image/jpeg
     {binary data}                        trailer = Foo
     0
     Foo: bar                         DATA
                                        - END_STREAM
                                      {binary data}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar





Belshe, et al.               Standards Track                   [Page 59]

RFC 7540                         HTTP/2                         May 2015


8.1.4.  Request Reliability Mechanisms in HTTP/2

   In HTTP/1.1, an HTTP client is unable to retry a non-idempotent
   request when an error occurs because there is no means to determine
   the nature of the error.  It is possible that some server processing
   occurred prior to the error, which could result in undesirable
   effects if the request were reattempted.

   HTTP/2 provides two mechanisms for providing a guarantee to a client
   that a request has not been processed:

   o  The GOAWAY frame indicates the highest stream number that might
      have been processed.  Requests on streams with higher numbers are
      therefore guaranteed to be safe to retry.

   o  The REFUSED_STREAM error code can be included in a RST_STREAM
      frame to indicate that the stream is being closed prior to any
      processing having occurred.  Any request that was sent on the
      reset stream can be safely retried.

   Requests that have not been processed have not failed; clients MAY
   automatically retry them, even those with non-idempotent methods.

   A server MUST NOT indicate that a stream has not been processed
   unless it can guarantee that fact.  If frames that are on a stream
   are passed to the application layer for any stream, then
   REFUSED_STREAM MUST NOT be used for that stream, and a GOAWAY frame
   MUST include a stream identifier that is greater than or equal to the
   given stream identifier.

   In addition to these mechanisms, the PING frame provides a way for a
   client to easily test a connection.  Connections that remain idle can
   become broken as some middleboxes (for instance, network address
   translators or load balancers) silently discard connection bindings.
   The PING frame allows a client to safely test whether a connection is
   still active without sending a request.

8.2.  Server Push

   HTTP/2 allows a server to pre-emptively send (or "push") responses
   (along with corresponding "promised" requests) to a client in
   association with a previous client-initiated request.  This can be
   useful when the server knows the client will need to have those
   responses available in order to fully process the response to the
   original request.






Belshe, et al.               Standards Track                   [Page 60]

RFC 7540                         HTTP/2                         May 2015


   A client can request that server push be disabled, though this is
   negotiated for each hop independently.  The SETTINGS_ENABLE_PUSH
   setting can be set to 0 to indicate that server push is disabled.

   Promised requests MUST be cacheable (see [RFC7231], Section 4.2.3),
   MUST be safe (see [RFC7231], Section 4.2.1), and MUST NOT include a
   request body.  Clients that receive a promised request that is not
   cacheable, that is not known to be safe, or that indicates the
   presence of a request body MUST reset the promised stream with a
   stream error (Section 5.4.2) of type PROTOCOL_ERROR.  Note this could
   result in the promised stream being reset if the client does not
   recognize a newly defined method as being safe.

   Pushed responses that are cacheable (see [RFC7234], Section 3) can be
   stored by the client, if it implements an HTTP cache.  Pushed
   responses are considered successfully validated on the origin server
   (e.g., if the "no-cache" cache response directive is present
   ([RFC7234], Section 5.2.2)) while the stream identified by the
   promised stream ID is still open.

   Pushed responses that are not cacheable MUST NOT be stored by any
   HTTP cache.  They MAY be made available to the application
   separately.

   The server MUST include a value in the ":authority" pseudo-header
   field for which the server is authoritative (see Section 10.1).  A
   client MUST treat a PUSH_PROMISE for which the server is not
   authoritative as a stream error (Section 5.4.2) of type
   PROTOCOL_ERROR.

   An intermediary can receive pushes from the server and choose not to
   forward them on to the client.  In other words, how to make use of
   the pushed information is up to that intermediary.  Equally, the
   intermediary might choose to make additional pushes to the client,
   without any action taken by the server.

   A client cannot push.  Thus, servers MUST treat the receipt of a
   PUSH_PROMISE frame as a connection error (Section 5.4.1) of type
   PROTOCOL_ERROR.  Clients MUST reject any attempt to change the
   SETTINGS_ENABLE_PUSH setting to a value other than 0 by treating the
   message as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.

8.2.1.  Push Requests

   Server push is semantically equivalent to a server responding to a
   request; however, in this case, that request is also sent by the
   server, as a PUSH_PROMISE frame.




Belshe, et al.               Standards Track                   [Page 61]

RFC 7540                         HTTP/2                         May 2015


   The PUSH_PROMISE frame includes a header block that contains a
   complete set of request header fields that the server attributes to
   the request.  It is not possible to push a response to a request that
   includes a request body.

   Pushed responses are always associated with an explicit request from
   the client.  The PUSH_PROMISE frames sent by the server are sent on
   that explicit request's stream.  The PUSH_PROMISE frame also includes
   a promised stream identifier, chosen from the stream identifiers
   available to the server (see Section 5.1.1).

   The header fields in PUSH_PROMISE and any subsequent CONTINUATION
   frames MUST be a valid and complete set of request header fields
   (Section 8.1.2.3).  The server MUST include a method in the ":method"
   pseudo-header field that is safe and cacheable.  If a client receives
   a PUSH_PROMISE that does not include a complete and valid set of
   header fields or the ":method" pseudo-header field identifies a
   method that is not safe, it MUST respond with a stream error
   (Section 5.4.2) of type PROTOCOL_ERROR.

   The server SHOULD send PUSH_PROMISE (Section 6.6) frames prior to
   sending any frames that reference the promised responses.  This
   avoids a race where clients issue requests prior to receiving any
   PUSH_PROMISE frames.

   For example, if the server receives a request for a document
   containing embedded links to multiple image files and the server
   chooses to push those additional images to the client, sending
   PUSH_PROMISE frames before the DATA frames that contain the image
   links ensures that the client is able to see that a resource will be
   pushed before discovering embedded links.  Similarly, if the server
   pushes responses referenced by the header block (for instance, in
   Link header fields), sending a PUSH_PROMISE before sending the header
   block ensures that clients do not request those resources.

   PUSH_PROMISE frames MUST NOT be sent by the client.

   PUSH_PROMISE frames can be sent by the server in response to any
   client-initiated stream, but the stream MUST be in either the "open"
   or "half-closed (remote)" state with respect to the server.
   PUSH_PROMISE frames are interspersed with the frames that comprise a
   response, though they cannot be interspersed with HEADERS and
   CONTINUATION frames that comprise a single header block.

   Sending a PUSH_PROMISE frame creates a new stream and puts the stream
   into the "reserved (local)" state for the server and the "reserved
   (remote)" state for the client.




Belshe, et al.               Standards Track                   [Page 62]

RFC 7540                         HTTP/2                         May 2015


8.2.2.  Push Responses

   After sending the PUSH_PROMISE frame, the server can begin delivering
   the pushed response as a response (Section 8.1.2.4) on a server-
   initiated stream that uses the promised stream identifier.  The
   server uses this stream to transmit an HTTP response, using the same
   sequence of frames as defined in Section 8.1.  This stream becomes
   "half-closed" to the client (Section 5.1) after the initial HEADERS
   frame is sent.

   Once a client receives a PUSH_PROMISE frame and chooses to accept the
   pushed response, the client SHOULD NOT issue any requests for the
   promised response until after the promised stream has closed.

   If the client determines, for any reason, that it does not wish to
   receive the pushed response from the server or if the server takes
   too long to begin sending the promised response, the client can send
   a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code
   and referencing the pushed stream's identifier.

   A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit
   the number of responses that can be concurrently pushed by a server.
   Advertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables
   server push by preventing the server from creating the necessary
   streams.  This does not prohibit a server from sending PUSH_PROMISE
   frames; clients need to reset any promised streams that are not
   wanted.

   Clients receiving a pushed response MUST validate that either the
   server is authoritative (see Section 10.1) or the proxy that provided
   the pushed response is configured for the corresponding request.  For
   example, a server that offers a certificate for only the
   "example.com" DNS-ID or Common Name is not permitted to push a
   response for "https://www.example.org/doc".

   The response for a PUSH_PROMISE stream begins with a HEADERS frame,
   which immediately puts the stream into the "half-closed (remote)"
   state for the server and "half-closed (local)" state for the client,
   and ends with a frame bearing END_STREAM, which places the stream in
   the "closed" state.

      Note: The client never sends a frame with the END_STREAM flag for
      a server push.








Belshe, et al.               Standards Track                   [Page 63]

RFC 7540                         HTTP/2                         May 2015


8.3.  The CONNECT Method

   In HTTP/1.x, the pseudo-method CONNECT ([RFC7231], Section 4.3.6) is
   used to convert an HTTP connection into a tunnel to a remote host.
   CONNECT is primarily used with HTTP proxies to establish a TLS
   session with an origin server for the purposes of interacting with
   "https" resources.

   In HTTP/2, the CONNECT method is used to establish a tunnel over a
   single HTTP/2 stream to a remote host for similar purposes.  The HTTP
   header field mapping works as defined in Section 8.1.2.3 ("Request
   Pseudo-Header Fields"), with a few differences.  Specifically:

   o  The ":method" pseudo-header field is set to "CONNECT".

   o  The ":scheme" and ":path" pseudo-header fields MUST be omitted.

   o  The ":authority" pseudo-header field contains the host and port to
      connect to (equivalent to the authority-form of the request-target
      of CONNECT requests (see [RFC7230], Section 5.3)).

   A CONNECT request that does not conform to these restrictions is
   malformed (Section 8.1.2.6).

   A proxy that supports CONNECT establishes a TCP connection [TCP] to
   the server identified in the ":authority" pseudo-header field.  Once
   this connection is successfully established, the proxy sends a
   HEADERS frame containing a 2xx series status code to the client, as
   defined in [RFC7231], Section 4.3.6.

   After the initial HEADERS frame sent by each peer, all subsequent
   DATA frames correspond to data sent on the TCP connection.  The
   payload of any DATA frames sent by the client is transmitted by the
   proxy to the TCP server; data received from the TCP server is
   assembled into DATA frames by the proxy.  Frame types other than DATA
   or stream management frames (RST_STREAM, WINDOW_UPDATE, and PRIORITY)
   MUST NOT be sent on a connected stream and MUST be treated as a
   stream error (Section 5.4.2) if received.

   The TCP connection can be closed by either peer.  The END_STREAM flag
   on a DATA frame is treated as being equivalent to the TCP FIN bit.  A
   client is expected to send a DATA frame with the END_STREAM flag set
   after receiving a frame bearing the END_STREAM flag.  A proxy that
   receives a DATA frame with the END_STREAM flag set sends the attached
   data with the FIN bit set on the last TCP segment.  A proxy that
   receives a TCP segment with the FIN bit set sends a DATA frame with
   the END_STREAM flag set.  Note that the final TCP segment or DATA
   frame could be empty.



Belshe, et al.               Standards Track                   [Page 64]

RFC 7540                         HTTP/2                         May 2015


   A TCP connection error is signaled with RST_STREAM.  A proxy treats
   any error in the TCP connection, which includes receiving a TCP
   segment with the RST bit set, as a stream error (Section 5.4.2) of
   type CONNECT_ERROR.  Correspondingly, a proxy MUST send a TCP segment
   with the RST bit set if it detects an error with the stream or the
   HTTP/2 connection.

9.  Additional HTTP Requirements/Considerations

   This section outlines attributes of the HTTP protocol that improve
   interoperability, reduce exposure to known security vulnerabilities,
   or reduce the potential for implementation variation.

9.1.  Connection Management

   HTTP/2 connections are persistent.  For best performance, it is
   expected that clients will not close connections until it is
   determined that no further communication with a server is necessary
   (for example, when a user navigates away from a particular web page)
   or until the server closes the connection.

   Clients SHOULD NOT open more than one HTTP/2 connection to a given
   host and port pair, where the host is derived from a URI, a selected
   alternative service [ALT-SVC], or a configured proxy.

   A client can create additional connections as replacements, either to
   replace connections that are near to exhausting the available stream
   identifier space (Section 5.1.1), to refresh the keying material for
   a TLS connection, or to replace connections that have encountered
   errors (Section 5.4.1).

   A client MAY open multiple connections to the same IP address and TCP
   port using different Server Name Indication [TLS-EXT] values or to
   provide different TLS client certificates but SHOULD avoid creating
   multiple connections with the same configuration.

   Servers are encouraged to maintain open connections for as long as
   possible but are permitted to terminate idle connections if
   necessary.  When either endpoint chooses to close the transport-layer
   TCP connection, the terminating endpoint SHOULD first send a GOAWAY
   (Section 6.8) frame so that both endpoints can reliably determine
   whether previously sent frames have been processed and gracefully
   complete or terminate any necessary remaining tasks.








Belshe, et al.               Standards Track                   [Page 65]

RFC 7540                         HTTP/2                         May 2015


9.1.1.  Connection Reuse

   Connections that are made to an origin server, either directly or
   through a tunnel created using the CONNECT method (Section 8.3), MAY
   be reused for requests with multiple different URI authority
   components.  A connection can be reused as long as the origin server
   is authoritative (Section 10.1).  For TCP connections without TLS,
   this depends on the host having resolved to the same IP address.

   For "https" resources, connection reuse additionally depends on
   having a certificate that is valid for the host in the URI.  The
   certificate presented by the server MUST satisfy any checks that the
   client would perform when forming a new TLS connection for the host
   in the URI.

   An origin server might offer a certificate with multiple
   "subjectAltName" attributes or names with wildcards, one of which is
   valid for the authority in the URI.  For example, a certificate with
   a "subjectAltName" of "*.example.com" might permit the use of the
   same connection for requests to URIs starting with
   "https://a.example.com/" and "https://b.example.com/".

   In some deployments, reusing a connection for multiple origins can
   result in requests being directed to the wrong origin server.  For
   example, TLS termination might be performed by a middlebox that uses
   the TLS Server Name Indication (SNI) [TLS-EXT] extension to select an
   origin server.  This means that it is possible for clients to send
   confidential information to servers that might not be the intended
   target for the request, even though the server is otherwise
   authoritative.

   A server that does not wish clients to reuse connections can indicate
   that it is not authoritative for a request by sending a 421
   (Misdirected Request) status code in response to the request (see
   Section 9.1.2).

   A client that is configured to use a proxy over HTTP/2 directs
   requests to that proxy through a single connection.  That is, all
   requests sent via a proxy reuse the connection to the proxy.

9.1.2.  The 421 (Misdirected Request) Status Code

   The 421 (Misdirected Request) status code indicates that the request
   was directed at a server that is not able to produce a response.
   This can be sent by a server that is not configured to produce
   responses for the combination of scheme and authority that are
   included in the request URI.




Belshe, et al.               Standards Track                   [Page 66]

RFC 7540                         HTTP/2                         May 2015


   Clients receiving a 421 (Misdirected Request) response from a server
   MAY retry the request -- whether the request method is idempotent or
   not -- over a different connection.  This is possible if a connection
   is reused (Section 9.1.1) or if an alternative service is selected
   [ALT-SVC].

   This status code MUST NOT be generated by proxies.

   A 421 response is cacheable by default, i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   Section 4.2.2 of [RFC7234]).

9.2.  Use of TLS Features

   Implementations of HTTP/2 MUST use TLS version 1.2 [TLS12] or higher
   for HTTP/2 over TLS.  The general TLS usage guidance in [TLSBCP]
   SHOULD be followed, with some additional restrictions that are
   specific to HTTP/2.

   The TLS implementation MUST support the Server Name Indication (SNI)
   [TLS-EXT] extension to TLS.  HTTP/2 clients MUST indicate the target
   domain name when negotiating TLS.

   Deployments of HTTP/2 that negotiate TLS 1.3 or higher need only
   support and use the SNI extension; deployments of TLS 1.2 are subject
   to the requirements in the following sections.  Implementations are
   encouraged to provide defaults that comply, but it is recognized that
   deployments are ultimately responsible for compliance.

9.2.1.  TLS 1.2 Features

   This section describes restrictions on the TLS 1.2 feature set that
   can be used with HTTP/2.  Due to deployment limitations, it might not
   be possible to fail TLS negotiation when these restrictions are not
   met.  An endpoint MAY immediately terminate an HTTP/2 connection that
   does not meet these TLS requirements with a connection error
   (Section 5.4.1) of type INADEQUATE_SECURITY.

   A deployment of HTTP/2 over TLS 1.2 MUST disable compression.  TLS
   compression can lead to the exposure of information that would not
   otherwise be revealed [RFC3749].  Generic compression is unnecessary
   since HTTP/2 provides compression features that are more aware of
   context and therefore likely to be more appropriate for use for
   performance, security, or other reasons.

   A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation.  An
   endpoint MUST treat a TLS renegotiation as a connection error
   (Section 5.4.1) of type PROTOCOL_ERROR.  Note that disabling



Belshe, et al.               Standards Track                   [Page 67]

RFC 7540                         HTTP/2                         May 2015


   renegotiation can result in long-lived connections becoming unusable
   due to limits on the number of messages the underlying cipher suite
   can encipher.

   An endpoint MAY use renegotiation to provide confidentiality
   protection for client credentials offered in the handshake, but any
   renegotiation MUST occur prior to sending the connection preface.  A
   server SHOULD request a client certificate if it sees a renegotiation
   request immediately after establishing a connection.

   This effectively prevents the use of renegotiation in response to a
   request for a specific protected resource.  A future specification
   might provide a way to support this use case.  Alternatively, a
   server might use an error (Section 5.4) of type HTTP_1_1_REQUIRED to
   request the client use a protocol that supports renegotiation.

   Implementations MUST support ephemeral key exchange sizes of at least
   2048 bits for cipher suites that use ephemeral finite field Diffie-
   Hellman (DHE) [TLS12] and 224 bits for cipher suites that use
   ephemeral elliptic curve Diffie-Hellman (ECDHE) [RFC4492].  Clients
   MUST accept DHE sizes of up to 4096 bits.  Endpoints MAY treat
   negotiation of key sizes smaller than the lower limits as a
   connection error (Section 5.4.1) of type INADEQUATE_SECURITY.

9.2.2.  TLS 1.2 Cipher Suites

   A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the cipher
   suites that are listed in the cipher suite black list (Appendix A).

   Endpoints MAY choose to generate a connection error (Section 5.4.1)
   of type INADEQUATE_SECURITY if one of the cipher suites from the
   black list is negotiated.  A deployment that chooses to use a black-
   listed cipher suite risks triggering a connection error unless the
   set of potential peers is known to accept that cipher suite.

   Implementations MUST NOT generate this error in reaction to the
   negotiation of a cipher suite that is not on the black list.
   Consequently, when clients offer a cipher suite that is not on the
   black list, they have to be prepared to use that cipher suite with
   HTTP/2.

   The black list includes the cipher suite that TLS 1.2 makes
   mandatory, which means that TLS 1.2 deployments could have non-
   intersecting sets of permitted cipher suites.  To avoid this problem
   causing TLS handshake failures, deployments of HTTP/2 that use TLS
   1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE]
   with the P-256 elliptic curve [FIPS186].




Belshe, et al.               Standards Track                   [Page 68]

RFC 7540                         HTTP/2                         May 2015


   Note that clients might advertise support of cipher suites that are
   on the black list in order to allow for connection to servers that do
   not support HTTP/2.  This allows servers to select HTTP/1.1 with a
   cipher suite that is on the HTTP/2 black list.  However, this can
   result in HTTP/2 being negotiated with a black-listed cipher suite if
   the application protocol and cipher suite are independently selected.

10.  Security Considerations

10.1.  Server Authority

   HTTP/2 relies on the HTTP/1.1 definition of authority for determining
   whether a server is authoritative in providing a given response (see
   [RFC7230], Section 9.1).  This relies on local name resolution for
   the "http" URI scheme and the authenticated server identity for the
   "https" scheme (see [RFC2818], Section 3).

10.2.  Cross-Protocol Attacks

   In a cross-protocol attack, an attacker causes a client to initiate a
   transaction in one protocol toward a server that understands a
   different protocol.  An attacker might be able to cause the
   transaction to appear as a valid transaction in the second protocol.
   In combination with the capabilities of the web context, this can be
   used to interact with poorly protected servers in private networks.

   Completing a TLS handshake with an ALPN identifier for HTTP/2 can be
   considered sufficient protection against cross-protocol attacks.
   ALPN provides a positive indication that a server is willing to
   proceed with HTTP/2, which prevents attacks on other TLS-based
   protocols.

   The encryption in TLS makes it difficult for attackers to control the
   data that could be used in a cross-protocol attack on a cleartext
   protocol.

   The cleartext version of HTTP/2 has minimal protection against cross-
   protocol attacks.  The connection preface (Section 3.5) contains a
   string that is designed to confuse HTTP/1.1 servers, but no special
   protection is offered for other protocols.  A server that is willing
   to ignore parts of an HTTP/1.1 request containing an Upgrade header
   field in addition to the client connection preface could be exposed
   to a cross-protocol attack.








Belshe, et al.               Standards Track                   [Page 69]

RFC 7540                         HTTP/2                         May 2015


10.3.  Intermediary Encapsulation Attacks

   The HTTP/2 header field encoding allows the expression of names that
   are not valid field names in the Internet Message Syntax used by
   HTTP/1.1.  Requests or responses containing invalid header field
   names MUST be treated as malformed (Section 8.1.2.6).  An
   intermediary therefore cannot translate an HTTP/2 request or response
   containing an invalid field name into an HTTP/1.1 message.

   Similarly, HTTP/2 allows header field values that are not valid.
   While most of the values that can be encoded will not alter header
   field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII
   0xa), and the zero character (NUL, ASCII 0x0) might be exploited by
   an attacker if they are translated verbatim.  Any request or response
   that contains a character not permitted in a header field value MUST
   be treated as malformed (Section 8.1.2.6).  Valid characters are
   defined by the "field-content" ABNF rule in Section 3.2 of [RFC7230].

10.4.  Cacheability of Pushed Responses

   Pushed responses do not have an explicit request from the client; the
   request is provided by the server in the PUSH_PROMISE frame.

   Caching responses that are pushed is possible based on the guidance
   provided by the origin server in the Cache-Control header field.
   However, this can cause issues if a single server hosts more than one
   tenant.  For example, a server might offer multiple users each a
   small portion of its URI space.

   Where multiple tenants share space on the same server, that server
   MUST ensure that tenants are not able to push representations of
   resources that they do not have authority over.  Failure to enforce
   this would allow a tenant to provide a representation that would be
   served out of cache, overriding the actual representation that the
   authoritative tenant provides.

   Pushed responses for which an origin server is not authoritative (see
   Section 10.1) MUST NOT be used or cached.

10.5.  Denial-of-Service Considerations

   An HTTP/2 connection can demand a greater commitment of resources to
   operate than an HTTP/1.1 connection.  The use of header compression
   and flow control depend on a commitment of resources for storing a
   greater amount of state.  Settings for these features ensure that
   memory commitments for these features are strictly bounded.





Belshe, et al.               Standards Track                   [Page 70]

RFC 7540                         HTTP/2                         May 2015


   The number of PUSH_PROMISE frames is not constrained in the same
   fashion.  A client that accepts server push SHOULD limit the number
   of streams it allows to be in the "reserved (remote)" state.  An
   excessive number of server push streams can be treated as a stream
   error (Section 5.4.2) of type ENHANCE_YOUR_CALM.

   Processing capacity cannot be guarded as effectively as state
   capacity.

   The SETTINGS frame can be abused to cause a peer to expend additional
   processing time.  This might be done by pointlessly changing SETTINGS
   parameters, setting multiple undefined parameters, or changing the
   same setting multiple times in the same frame.  WINDOW_UPDATE or
   PRIORITY frames can be abused to cause an unnecessary waste of
   resources.

   Large numbers of small or empty frames can be abused to cause a peer
   to expend time processing frame headers.  Note, however, that some
   uses are entirely legitimate, such as the sending of an empty DATA or
   CONTINUATION frame at the end of a stream.

   Header compression also offers some opportunities to waste processing
   resources; see Section 7 of [COMPRESSION] for more details on
   potential abuses.

   Limits in SETTINGS parameters cannot be reduced instantaneously,
   which leaves an endpoint exposed to behavior from a peer that could
   exceed the new limits.  In particular, immediately after establishing
   a connection, limits set by a server are not known to clients and
   could be exceeded without being an obvious protocol violation.

   All these features -- i.e., SETTINGS changes, small frames, header
   compression -- have legitimate uses.  These features become a burden
   only when they are used unnecessarily or to excess.

   An endpoint that doesn't monitor this behavior exposes itself to a
   risk of denial-of-service attack.  Implementations SHOULD track the
   use of these features and set limits on their use.  An endpoint MAY
   treat activity that is suspicious as a connection error
   (Section 5.4.1) of type ENHANCE_YOUR_CALM.

10.5.1.  Limits on Header Block Size

   A large header block (Section 4.3) can cause an implementation to
   commit a large amount of state.  Header fields that are critical for
   routing can appear toward the end of a header block, which prevents
   streaming of header fields to their ultimate destination.  This
   ordering and other reasons, such as ensuring cache correctness, mean



Belshe, et al.               Standards Track                   [Page 71]

RFC 7540                         HTTP/2                         May 2015


   that an endpoint might need to buffer the entire header block.  Since
   there is no hard limit to the size of a header block, some endpoints
   could be forced to commit a large amount of available memory for
   header fields.

   An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers
   of limits that might apply on the size of header blocks.  This
   setting is only advisory, so endpoints MAY choose to send header
   blocks that exceed this limit and risk having the request or response
   being treated as malformed.  This setting is specific to a
   connection, so any request or response could encounter a hop with a
   lower, unknown limit.  An intermediary can attempt to avoid this
   problem by passing on values presented by different peers, but they
   are not obligated to do so.

   A server that receives a larger header block than it is willing to
   handle can send an HTTP 431 (Request Header Fields Too Large) status
   code [RFC6585].  A client can discard responses that it cannot
   process.  The header block MUST be processed to ensure a consistent
   connection state, unless the connection is closed.

10.5.2.  CONNECT Issues

   The CONNECT method can be used to create disproportionate load on an
   proxy, since stream creation is relatively inexpensive when compared
   to the creation and maintenance of a TCP connection.  A proxy might
   also maintain some resources for a TCP connection beyond the closing
   of the stream that carries the CONNECT request, since the outgoing
   TCP connection remains in the TIME_WAIT state.  Therefore, a proxy
   cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the
   resources consumed by CONNECT requests.

10.6.  Use of Compression

   Compression can allow an attacker to recover secret data when it is
   compressed in the same context as data under attacker control.
   HTTP/2 enables compression of header fields (Section 4.3); the
   following concerns also apply to the use of HTTP compressed content-
   codings ([RFC7231], Section 3.1.2.1).

   There are demonstrable attacks on compression that exploit the
   characteristics of the web (e.g., [BREACH]).  The attacker induces
   multiple requests containing varying plaintext, observing the length
   of the resulting ciphertext in each, which reveals a shorter length
   when a guess about the secret is correct.






Belshe, et al.               Standards Track                   [Page 72]

RFC 7540                         HTTP/2                         May 2015


   Implementations communicating on a secure channel MUST NOT compress
   content that includes both confidential and attacker-controlled data
   unless separate compression dictionaries are used for each source of
   data.  Compression MUST NOT be used if the source of data cannot be
   reliably determined.  Generic stream compression, such as that
   provided by TLS, MUST NOT be used with HTTP/2 (see Section 9.2).

   Further considerations regarding the compression of header fields are
   described in [COMPRESSION].

10.7.  Use of Padding

   Padding within HTTP/2 is not intended as a replacement for general
   purpose padding, such as might be provided by TLS [TLS12].  Redundant
   padding could even be counterproductive.  Correct application can
   depend on having specific knowledge of the data that is being padded.

   To mitigate attacks that rely on compression, disabling or limiting
   compression might be preferable to padding as a countermeasure.

   Padding can be used to obscure the exact size of frame content and is
   provided to mitigate specific attacks within HTTP, for example,
   attacks where compressed content includes both attacker-controlled
   plaintext and secret data (e.g., [BREACH]).

   Use of padding can result in less protection than might seem
   immediately obvious.  At best, padding only makes it more difficult
   for an attacker to infer length information by increasing the number
   of frames an attacker has to observe.  Incorrectly implemented
   padding schemes can be easily defeated.  In particular, randomized
   padding with a predictable distribution provides very little
   protection; similarly, padding payloads to a fixed size exposes
   information as payload sizes cross the fixed-sized boundary, which
   could be possible if an attacker can control plaintext.

   Intermediaries SHOULD retain padding for DATA frames but MAY drop
   padding for HEADERS and PUSH_PROMISE frames.  A valid reason for an
   intermediary to change the amount of padding of frames is to improve
   the protections that padding provides.

10.8.  Privacy Considerations

   Several characteristics of HTTP/2 provide an observer an opportunity
   to correlate actions of a single client or server over time.  These
   include the value of settings, the manner in which flow-control
   windows are managed, the way priorities are allocated to streams, the
   timing of reactions to stimulus, and the handling of any features
   that are controlled by settings.



Belshe, et al.               Standards Track                   [Page 73]

RFC 7540                         HTTP/2                         May 2015


   As far as these create observable differences in behavior, they could
   be used as a basis for fingerprinting a specific client, as defined
   in Section 1.8 of [HTML5].

   HTTP/2's preference for using a single TCP connection allows
   correlation of a user's activity on a site.  Reusing connections for
   different origins allows tracking across those origins.

   Because the PING and SETTINGS frames solicit immediate responses,
   they can be used by an endpoint to measure latency to their peer.
   This might have privacy implications in certain scenarios.

11.  IANA Considerations

   A string for identifying HTTP/2 is entered into the "Application-
   Layer Protocol Negotiation (ALPN) Protocol IDs" registry established
   in [TLS-ALPN].

   This document establishes a registry for frame types, settings, and
   error codes.  These new registries appear in the new "Hypertext
   Transfer Protocol version 2 (HTTP/2) Parameters" section.

   This document registers the HTTP2-Settings header field for use in
   HTTP; it also registers the 421 (Misdirected Request) status code.

   This document registers the "PRI" method for use in HTTP to avoid
   collisions with the connection preface (Section 3.5).

11.1.  Registration of HTTP/2 Identification Strings

   This document creates two registrations for the identification of
   HTTP/2 (see Section 3.3) in the "Application-Layer Protocol
   Negotiation (ALPN) Protocol IDs" registry established in [TLS-ALPN].

   The "h2" string identifies HTTP/2 when used over TLS:

   Protocol:  HTTP/2 over TLS

   Identification Sequence:  0x68 0x32 ("h2")

   Specification:  This document

   The "h2c" string identifies HTTP/2 when used over cleartext TCP:

   Protocol:  HTTP/2 over TCP






Belshe, et al.               Standards Track                   [Page 74]

RFC 7540                         HTTP/2                         May 2015


   Identification Sequence:  0x68 0x32 0x63 ("h2c")

   Specification:  This document

11.2.  Frame Type Registry

   This document establishes a registry for HTTP/2 frame type codes.
   The "HTTP/2 Frame Type" registry manages an 8-bit space.  The "HTTP/2
   Frame Type" registry operates under either of the "IETF Review" or
   "IESG Approval" policies [RFC5226] for values between 0x00 and 0xef,
   with values between 0xf0 and 0xff being reserved for Experimental
   Use.

   New entries in this registry require the following information:

   Frame Type:  A name or label for the frame type.

   Code:  The 8-bit code assigned to the frame type.

   Specification:  A reference to a specification that includes a
      description of the frame layout, its semantics, and flags that the
      frame type uses, including any parts of the frame that are
      conditionally present based on the value of flags.

   The entries in the following table are registered by this document.

   +---------------+------+--------------+
   | Frame Type    | Code | Section      |
   +---------------+------+--------------+
   | DATA          | 0x0  | Section 6.1  |
   | HEADERS       | 0x1  | Section 6.2  |
   | PRIORITY      | 0x2  | Section 6.3  |
   | RST_STREAM    | 0x3  | Section 6.4  |
   | SETTINGS      | 0x4  | Section 6.5  |
   | PUSH_PROMISE  | 0x5  | Section 6.6  |
   | PING          | 0x6  | Section 6.7  |
   | GOAWAY        | 0x7  | Section 6.8  |
   | WINDOW_UPDATE | 0x8  | Section 6.9  |
   | CONTINUATION  | 0x9  | Section 6.10 |
   +---------------+------+--------------+

11.3.  Settings Registry

   This document establishes a registry for HTTP/2 settings.  The
   "HTTP/2 Settings" registry manages a 16-bit space.  The "HTTP/2
   Settings" registry operates under the "Expert Review" policy
   [RFC5226] for values in the range from 0x0000 to 0xefff, with values
   between and 0xf000 and 0xffff being reserved for Experimental Use.



Belshe, et al.               Standards Track                   [Page 75]

RFC 7540                         HTTP/2                         May 2015


   New registrations are advised to provide the following information:

   Name:  A symbolic name for the setting.  Specifying a setting name is
      optional.

   Code:  The 16-bit code assigned to the setting.

   Initial Value:  An initial value for the setting.

   Specification:  An optional reference to a specification that
      describes the use of the setting.

   The entries in the following table are registered by this document.

   +------------------------+------+---------------+---------------+
   | Name                   | Code | Initial Value | Specification |
   +------------------------+------+---------------+---------------+
   | HEADER_TABLE_SIZE      | 0x1  | 4096          | Section 6.5.2 |
   | ENABLE_PUSH            | 0x2  | 1             | Section 6.5.2 |
   | MAX_CONCURRENT_STREAMS | 0x3  | (infinite)    | Section 6.5.2 |
   | INITIAL_WINDOW_SIZE    | 0x4  | 65535         | Section 6.5.2 |
   | MAX_FRAME_SIZE         | 0x5  | 16384         | Section 6.5.2 |
   | MAX_HEADER_LIST_SIZE   | 0x6  | (infinite)    | Section 6.5.2 |
   +------------------------+------+---------------+---------------+

11.4.  Error Code Registry

   This document establishes a registry for HTTP/2 error codes.  The
   "HTTP/2 Error Code" registry manages a 32-bit space.  The "HTTP/2
   Error Code" registry operates under the "Expert Review" policy
   [RFC5226].

   Registrations for error codes are required to include a description
   of the error code.  An expert reviewer is advised to examine new
   registrations for possible duplication with existing error codes.
   Use of existing registrations is to be encouraged, but not mandated.

   New registrations are advised to provide the following information:

   Name:  A name for the error code.  Specifying an error code name is
      optional.

   Code:  The 32-bit error code value.

   Description:  A brief description of the error code semantics, longer
      if no detailed specification is provided.





Belshe, et al.               Standards Track                   [Page 76]

RFC 7540                         HTTP/2                         May 2015


   Specification:  An optional reference for a specification that
      defines the error code.

   The entries in the following table are registered by this document.

   +---------------------+------+----------------------+---------------+
   | Name                | Code | Description          | Specification |
   +---------------------+------+----------------------+---------------+
   | NO_ERROR            | 0x0  | Graceful shutdown    | Section 7     |
   | PROTOCOL_ERROR      | 0x1  | Protocol error       | Section 7     |
   |                     |      | detected             |               |
   | INTERNAL_ERROR      | 0x2  | Implementation fault | Section 7     |
   | FLOW_CONTROL_ERROR  | 0x3  | Flow-control limits  | Section 7     |
   |                     |      | exceeded             |               |
   | SETTINGS_TIMEOUT    | 0x4  | Settings not         | Section 7     |
   |                     |      | acknowledged         |               |
   | STREAM_CLOSED       | 0x5  | Frame received for   | Section 7     |
   |                     |      | closed stream        |               |
   | FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect | Section 7     |
   | REFUSED_STREAM      | 0x7  | Stream not processed | Section 7     |
   | CANCEL              | 0x8  | Stream cancelled     | Section 7     |
   | COMPRESSION_ERROR   | 0x9  | Compression state    | Section 7     |
   |                     |      | not updated          |               |
   | CONNECT_ERROR       | 0xa  | TCP connection error | Section 7     |
   |                     |      | for CONNECT method   |               |
   | ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | Section 7     |
   |                     |      | exceeded             |               |
   | INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | Section 7     |
   |                     |      | parameters not       |               |
   |                     |      | acceptable           |               |
   | HTTP_1_1_REQUIRED   | 0xd  | Use HTTP/1.1 for the | Section 7     |
   |                     |      | request              |               |
   +---------------------+------+----------------------+---------------+

11.5.  HTTP2-Settings Header Field Registration

   This section registers the HTTP2-Settings header field in the
   "Permanent Message Header Field Names" registry [BCP90].

   Header field name:  HTTP2-Settings

   Applicable protocol:  http

   Status:  standard

   Author/Change controller:  IETF





Belshe, et al.               Standards Track                   [Page 77]

RFC 7540                         HTTP/2                         May 2015


   Specification document(s):  Section 3.2.1 of this document

   Related information:  This header field is only used by an HTTP/2
      client for Upgrade-based negotiation.

11.6.  PRI Method Registration

   This section registers the "PRI" method in the "HTTP Method Registry"
   ([RFC7231], Section 8.1).

   Method Name:  PRI

   Safe:  Yes

   Idempotent:  Yes

   Specification document(s):  Section 3.5 of this document

   Related information:  This method is never used by an actual client.
      This method will appear to be used when an HTTP/1.1 server or
      intermediary attempts to parse an HTTP/2 connection preface.

11.7.  The 421 (Misdirected Request) HTTP Status Code

   This document registers the 421 (Misdirected Request) HTTP status
   code in the "HTTP Status Codes" registry ([RFC7231], Section 8.2).

   Status Code:  421

   Short Description:  Misdirected Request

   Specification:  Section 9.1.2 of this document

11.8.  The h2c Upgrade Token

   This document registers the "h2c" upgrade token in the "HTTP Upgrade
   Tokens" registry ([RFC7230], Section 8.6).

   Value:  h2c

   Description:  Hypertext Transfer Protocol version 2 (HTTP/2)

   Expected Version Tokens:  None

   Reference:  Section 3.2 of this document






Belshe, et al.               Standards Track                   [Page 78]

RFC 7540                         HTTP/2                         May 2015


12.  References

12.1.  Normative References

   [COMPRESSION] Peon, R. and H. Ruellan, "HPACK: Header Compression for
                 HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
                 <http://www.rfc-editor.org/info/rfc7541>.

   [COOKIE]      Barth, A., "HTTP State Management Mechanism", RFC 6265,
                 DOI 10.17487/RFC6265, April 2011,
                 <http://www.rfc-editor.org/info/rfc6265>.

   [FIPS186]     NIST, "Digital Signature Standard (DSS)", FIPS PUB
                 186-4, July 2013,
                 <http://dx.doi.org/10.6028/NIST.FIPS.186-4>.

   [RFC2119]     Bradner, S., "Key words for use in RFCs to Indicate
                 Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/
                 RFC2119, March 1997,
                 <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2818]     Rescorla, E., "HTTP Over TLS", RFC 2818, DOI 10.17487/
                 RFC2818, May 2000,
                 <http://www.rfc-editor.org/info/rfc2818>.

   [RFC3986]     Berners-Lee, T., Fielding, R., and L. Masinter,
                 "Uniform Resource Identifier (URI): Generic Syntax",
                 STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005,
                 <http://www.rfc-editor.org/info/rfc3986>.

   [RFC4648]     Josefsson, S., "The Base16, Base32, and Base64 Data
                 Encodings", RFC 4648, DOI 10.17487/RFC4648, October
                 2006, <http://www.rfc-editor.org/info/rfc4648>.

   [RFC5226]     Narten, T. and H. Alvestrand, "Guidelines for Writing
                 an IANA Considerations Section in RFCs", BCP 26,
                 RFC 5226, DOI 10.17487/RFC5226, May 2008,
                 <http://www.rfc-editor.org/info/rfc5226>.

   [RFC5234]     Crocker, D., Ed. and P. Overell, "Augmented BNF for
                 Syntax Specifications: ABNF", STD 68, RFC 5234,
                 DOI 10.17487/ RFC5234, January 2008,
                 <http://www.rfc-editor.org/info/rfc5234>.

   [RFC7230]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Message Syntax and
                 Routing", RFC 7230, DOI 10.17487/RFC7230, June 2014,
                 <http://www.rfc-editor.org/info/rfc7230>.



Belshe, et al.               Standards Track                   [Page 79]

RFC 7540                         HTTP/2                         May 2015


   [RFC7231]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Semantics and Content",
                 RFC 7231, DOI 10.17487/RFC7231, June 2014,
                 <http://www.rfc-editor.org/info/rfc7231>.

   [RFC7232]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Conditional Requests",
                 RFC 7232, DOI 10.17487/RFC7232, June 2014,
                 <http://www.rfc-editor.org/info/rfc7232>.

   [RFC7233]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
                 "Hypertext Transfer Protocol (HTTP/1.1): Range
                 Requests", RFC 7233, DOI 10.17487/RFC7233, June 2014,
                 <http://www.rfc-editor.org/info/rfc7233>.

   [RFC7234]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
                 Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
                 RFC 7234, DOI 10.17487/RFC7234, June 2014,
                 <http://www.rfc-editor.org/info/rfc7234>.

   [RFC7235]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Authentication",
                 RFC 7235, DOI 10.17487/RFC7235, June 2014,
                 <http://www.rfc-editor.org/info/rfc7235>.

   [TCP]         Postel, J., "Transmission Control Protocol", STD 7, RFC
                 793, DOI 10.17487/RFC0793, September 1981,
                 <http://www.rfc-editor.org/info/rfc793>.

   [TLS-ALPN]    Friedl, S., Popov, A., Langley, A., and E. Stephan,
                 "Transport Layer Security (TLS) Application-Layer
                 Protocol Negotiation Extension", RFC 7301,
                 DOI 10.17487/RFC7301, July 2014,
                 <http://www.rfc-editor.org/info/rfc7301>.

   [TLS-ECDHE]   Rescorla, E., "TLS Elliptic Curve Cipher Suites with
                 SHA-256/384 and AES Galois Counter Mode (GCM)",
                 RFC 5289, DOI 10.17487/RFC5289, August 2008,
                 <http://www.rfc-editor.org/info/rfc5289>.

   [TLS-EXT]     Eastlake 3rd, D., "Transport Layer Security (TLS)
                 Extensions: Extension Definitions", RFC 6066,
                 DOI 10.17487/RFC6066, January 2011,
                 <http://www.rfc-editor.org/info/rfc6066>.







Belshe, et al.               Standards Track                   [Page 80]

RFC 7540                         HTTP/2                         May 2015


   [TLS12]       Dierks, T. and E. Rescorla, "The Transport Layer
                 Security (TLS) Protocol Version 1.2", RFC 5246,
                 DOI 10.17487/ RFC5246, August 2008,
                 <http://www.rfc-editor.org/info/rfc5246>.

12.2.  Informative References

   [ALT-SVC]     Nottingham, M., McManus, P., and J. Reschke, "HTTP
                 Alternative Services", Work in Progress, draft-ietf-
                 httpbis-alt-svc-06, February 2015.

   [BCP90]       Klyne, G., Nottingham, M., and J. Mogul, "Registration
                 Procedures for Message Header Fields", BCP 90,
                 RFC 3864, September 2004,
                 <http://www.rfc-editor.org/info/bcp90>.

   [BREACH]      Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving
                 the CRIME Attack", July 2013,
                 <http://breachattack.com/resources/
                 BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

   [HTML5]       Hickson, I., Berjon, R., Faulkner, S., Leithead, T.,
                 Doyle Navara, E., O'Connor, E., and S. Pfeiffer,
                 "HTML5", W3C Recommendation REC-html5-20141028, October
                 2014, <http://www.w3.org/TR/2014/REC-html5-20141028/>.

   [RFC3749]     Hollenbeck, S., "Transport Layer Security Protocol
                 Compression Methods", RFC 3749, DOI 10.17487/RFC3749,
                 May 2004, <http://www.rfc-editor.org/info/rfc3749>.

   [RFC4492]     Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and
                 B.  Moeller, "Elliptic Curve Cryptography (ECC) Cipher
                 Suites for Transport Layer Security (TLS)", RFC 4492,
                 DOI 10.17487/RFC4492, May 2006,
                 <http://www.rfc-editor.org/info/rfc4492>.

   [RFC6585]     Nottingham, M. and R. Fielding, "Additional HTTP Status
                 Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012,
                 <http://www.rfc-editor.org/info/rfc6585>.

   [RFC7323]     Borman, D., Braden, B., Jacobson, V., and R.
                 Scheffenegger, Ed., "TCP Extensions for High
                 Performance", RFC 7323, DOI 10.17487/RFC7323, September
                 2014, <http://www.rfc-editor.org/info/rfc7323>.

   [TALKING]     Huang, L., Chen, E., Barth, A., Rescorla, E., and C.
                 Jackson, "Talking to Yourself for Fun and Profit",
                 2011, <http://w2spconf.com/2011/papers/websocket.pdf>.



Belshe, et al.               Standards Track                   [Page 81]

RFC 7540                         HTTP/2                         May 2015


   [TLSBCP]      Sheffer, Y., Holz, R., and P. Saint-Andre,
                 "Recommendations for Secure Use of Transport Layer
                 Security (TLS) and Datagram Transport Layer Security
                 (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
                 2015, <http://www.rfc-editor.org/info/rfc7525>.














































Belshe, et al.               Standards Track                   [Page 82]

RFC 7540                         HTTP/2                         May 2015


Appendix A.  TLS 1.2 Cipher Suite Black List

   An HTTP/2 implementation MAY treat the negotiation of any of the
   following cipher suites with TLS 1.2 as a connection error
   (Section 5.4.1) of type INADEQUATE_SECURITY:

   o  TLS_NULL_WITH_NULL_NULL

   o  TLS_RSA_WITH_NULL_MD5

   o  TLS_RSA_WITH_NULL_SHA

   o  TLS_RSA_EXPORT_WITH_RC4_40_MD5

   o  TLS_RSA_WITH_RC4_128_MD5

   o  TLS_RSA_WITH_RC4_128_SHA

   o  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_RSA_WITH_IDEA_CBC_SHA

   o  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_RSA_WITH_DES_CBC_SHA

   o  TLS_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_DSS_WITH_DES_CBC_SHA

   o  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_RSA_WITH_DES_CBC_SHA

   o  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DHE_DSS_WITH_DES_CBC_SHA

   o  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA




Belshe, et al.               Standards Track                   [Page 83]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_DHE_RSA_WITH_DES_CBC_SHA

   o  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

   o  TLS_DH_anon_WITH_RC4_128_MD5

   o  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_anon_WITH_DES_CBC_SHA

   o  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_SHA

   o  TLS_KRB5_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_RC4_128_SHA

   o  TLS_KRB5_WITH_IDEA_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_MD5

   o  TLS_KRB5_WITH_3DES_EDE_CBC_MD5

   o  TLS_KRB5_WITH_RC4_128_MD5

   o  TLS_KRB5_WITH_IDEA_CBC_MD5

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC4_40_SHA

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC4_40_MD5

   o  TLS_PSK_WITH_NULL_SHA

   o  TLS_DHE_PSK_WITH_NULL_SHA

   o  TLS_RSA_PSK_WITH_NULL_SHA




Belshe, et al.               Standards Track                   [Page 84]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA

   o  TLS_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_NULL_SHA256

   o  TLS_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA




Belshe, et al.               Standards Track                   [Page 85]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_PSK_WITH_RC4_128_SHA

   o  TLS_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_PSK_WITH_AES_128_CBC_SHA

   o  TLS_PSK_WITH_AES_256_CBC_SHA

   o  TLS_DHE_PSK_WITH_RC4_128_SHA

   o  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_PSK_WITH_RC4_128_SHA

   o  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA




Belshe, et al.               Standards Track                   [Page 86]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_DSS_WITH_SEED_CBC_SHA

   o  TLS_DH_RSA_WITH_SEED_CBC_SHA

   o  TLS_DHE_DSS_WITH_SEED_CBC_SHA

   o  TLS_DHE_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_anon_WITH_SEED_CBC_SHA

   o  TLS_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_AES_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_AES_256_GCM_SHA384

   o  TLS_DH_anon_WITH_AES_128_GCM_SHA256

   o  TLS_DH_anon_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_PSK_WITH_NULL_SHA256

   o  TLS_PSK_WITH_NULL_SHA384

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256




Belshe, et al.               Standards Track                   [Page 87]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_NULL_SHA256

   o  TLS_DHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_NULL_SHA256

   o  TLS_RSA_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_EMPTY_RENEGOTIATION_INFO_SCSV

   o  TLS_ECDH_ECDSA_WITH_NULL_SHA

   o  TLS_ECDH_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA




Belshe, et al.               Standards Track                   [Page 88]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_NULL_SHA

   o  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_RSA_WITH_NULL_SHA

   o  TLS_ECDH_RSA_WITH_RC4_128_SHA

   o  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_NULL_SHA

   o  TLS_ECDHE_RSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_anon_WITH_NULL_SHA

   o  TLS_ECDH_anon_WITH_RC4_128_SHA

   o  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA




Belshe, et al.               Standards Track                   [Page 89]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_SRP_SHA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_RC4_128_SHA

   o  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384




Belshe, et al.               Standards Track                   [Page 90]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_ECDHE_PSK_WITH_NULL_SHA

   o  TLS_ECDHE_PSK_WITH_NULL_SHA256

   o  TLS_ECDHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_WITH_ARIA_128_GCM_SHA256




Belshe, et al.               Standards Track                   [Page 91]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256




Belshe, et al.               Standards Track                   [Page 92]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256




Belshe, et al.               Standards Track                   [Page 93]

RFC 7540                         HTTP/2                         May 2015


   o  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_AES_128_CCM

   o  TLS_RSA_WITH_AES_256_CCM

   o  TLS_RSA_WITH_AES_128_CCM_8

   o  TLS_RSA_WITH_AES_256_CCM_8

   o  TLS_PSK_WITH_AES_128_CCM

   o  TLS_PSK_WITH_AES_256_CCM

   o  TLS_PSK_WITH_AES_128_CCM_8

   o  TLS_PSK_WITH_AES_256_CCM_8

      Note: This list was assembled from the set of registered TLS
      cipher suites at the time of writing.  This list includes those
      cipher suites that do not offer an ephemeral key exchange and
      those that are based on the TLS null, stream, or block cipher type
      (as defined in Section 6.2.3 of [TLS12]).  Additional cipher
      suites with these properties could be defined; these would not be
      explicitly prohibited.














Belshe, et al.               Standards Track                   [Page 94]

RFC 7540                         HTTP/2                         May 2015


Acknowledgements

   This document includes substantial input from the following
   individuals:

   o  Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa
      Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam
      Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay,
      Paul Amer, Fan Yang, and Jonathan Leighton (SPDY contributors).

   o  Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).

   o  William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro,
      Jitu Padhye, Roberto Peon, and Rob Trace (Flow control).

   o  Mike Bishop (Extensibility).

   o  Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike
      Bishop, and Herve Ruellan (Substantial editorial contributions).

   o  Kari Hurtta, Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp,
      and Jonathan Thackray.

   o  Alexey Melnikov, who was an editor of this document in 2013.

   A substantial proportion of Martin's contribution was supported by
   Microsoft during his employment there.

   The Japanese HTTP/2 community provided invaluable contributions,
   including a number of implementations as well as numerous technical
   and editorial contributions.




















Belshe, et al.               Standards Track                   [Page 95]

RFC 7540                         HTTP/2                         May 2015


Authors' Addresses

   Mike Belshe
   BitGo

   EMail: mike@belshe.com


   Roberto Peon
   Google, Inc

   EMail: fenix@google.com


   Martin Thomson (editor)
   Mozilla
   331 E Evelyn Street
   Mountain View, CA  94041
   United States

   EMail: martin.thomson@gmail.com






























Belshe, et al.               Standards Track                   [Page 96]

